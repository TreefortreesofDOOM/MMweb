# Database Schema Documentation
Generated on: 2025-01-12 19:06:20
Connection: postgresql://postgres@192.168.86.29:54322/postgres

## Table of Contents
1. [Tables and Columns](#tables-and-columns)
2. [Foreign Key Relationships](#foreign-key-relationships)
3. [RLS Policies](#rls-policies)
4. [Functions](#functions)
5. [Triggers](#triggers)
6. [Views](#views)
7. [Indexes](#indexes)

## Tables and Columns

```sql
### Table: audit_log_entries
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| instance_id | uuid | YES |  |  |
| id | uuid | NO |  |  |
| payload | json | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| ip_address | character varying | NO | ''::character varying |  |
### Table: flow_state
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| user_id | uuid | YES |  |  |
| auth_code | text | NO |  |  |
| code_challenge_method | USER-DEFINED | NO |  |  |
| code_challenge | text | NO |  |  |
| provider_type | text | NO |  |  |
| provider_access_token | text | YES |  |  |
| provider_refresh_token | text | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
| authentication_method | text | NO |  |  |
| auth_code_issued_at | timestamp with time zone | YES |  |  |
### Table: identities
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| provider_id | text | NO |  |  |
| user_id | uuid | NO |  |  |
| identity_data | jsonb | NO |  |  |
| provider | text | NO |  |  |
| last_sign_in_at | timestamp with time zone | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
| email | text | YES |  | Auth: Email is a generated column that references the optional email property in the identity_data |
| id | uuid | NO | gen_random_uuid() |  |
### Table: instances
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| uuid | uuid | YES |  |  |
| raw_base_config | text | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
### Table: mfa_amr_claims
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| session_id | uuid | NO |  |  |
| created_at | timestamp with time zone | NO |  |  |
| updated_at | timestamp with time zone | NO |  |  |
| authentication_method | text | NO |  |  |
| id | uuid | NO |  |  |
### Table: mfa_challenges
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| factor_id | uuid | NO |  |  |
| created_at | timestamp with time zone | NO |  |  |
| verified_at | timestamp with time zone | YES |  |  |
| ip_address | inet | NO |  |  |
| otp_code | text | YES |  |  |
| web_authn_session_data | jsonb | YES |  |  |
### Table: mfa_factors
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| user_id | uuid | NO |  |  |
| friendly_name | text | YES |  |  |
| factor_type | USER-DEFINED | NO |  |  |
| status | USER-DEFINED | NO |  |  |
| created_at | timestamp with time zone | NO |  |  |
| updated_at | timestamp with time zone | NO |  |  |
| secret | text | YES |  |  |
| phone | text | YES |  |  |
| last_challenged_at | timestamp with time zone | YES |  |  |
| web_authn_credential | jsonb | YES |  |  |
| web_authn_aaguid | uuid | YES |  |  |
### Table: one_time_tokens
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| user_id | uuid | NO |  |  |
| token_type | USER-DEFINED | NO |  |  |
| token_hash | text | NO |  |  |
| relates_to | text | NO |  |  |
| created_at | timestamp without time zone | NO | now() |  |
| updated_at | timestamp without time zone | NO | now() |  |
### Table: refresh_tokens
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| instance_id | uuid | YES |  |  |
| id | bigint | NO | nextval('auth.refresh_tokens_id_seq'::regclass) |  |
| token | character varying | YES |  |  |
| user_id | character varying | YES |  |  |
| revoked | boolean | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
| parent | character varying | YES |  |  |
| session_id | uuid | YES |  |  |
### Table: saml_providers
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| sso_provider_id | uuid | NO |  |  |
| entity_id | text | NO |  |  |
| metadata_xml | text | NO |  |  |
| metadata_url | text | YES |  |  |
| attribute_mapping | jsonb | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
| name_id_format | text | YES |  |  |
### Table: saml_relay_states
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| sso_provider_id | uuid | NO |  |  |
| request_id | text | NO |  |  |
| for_email | text | YES |  |  |
| redirect_to | text | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
| flow_state_id | uuid | YES |  |  |
### Table: schema_migrations
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| version | character varying | NO |  |  |
### Table: sessions
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| user_id | uuid | NO |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
| factor_id | uuid | YES |  |  |
| aal | USER-DEFINED | YES |  |  |
| not_after | timestamp with time zone | YES |  | Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired. |
| refreshed_at | timestamp without time zone | YES |  |  |
| user_agent | text | YES |  |  |
| ip | inet | YES |  |  |
| tag | text | YES |  |  |
### Table: sso_domains
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| sso_provider_id | uuid | NO |  |  |
| domain | text | NO |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
### Table: sso_providers
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| resource_id | text | YES |  | Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code. |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
### Table: users
Schema: auth

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| instance_id | uuid | YES |  |  |
| id | uuid | NO |  |  |
| aud | character varying | YES |  |  |
| role | character varying | YES |  |  |
| email | character varying | YES |  |  |
| encrypted_password | character varying | YES |  |  |
| email_confirmed_at | timestamp with time zone | YES |  |  |
| invited_at | timestamp with time zone | YES |  |  |
| confirmation_token | character varying | YES |  |  |
| confirmation_sent_at | timestamp with time zone | YES |  |  |
| recovery_token | character varying | YES |  |  |
| recovery_sent_at | timestamp with time zone | YES |  |  |
| email_change_token_new | character varying | YES |  |  |
| email_change | character varying | YES |  |  |
| email_change_sent_at | timestamp with time zone | YES |  |  |
| last_sign_in_at | timestamp with time zone | YES |  |  |
| raw_app_meta_data | jsonb | YES |  |  |
| raw_user_meta_data | jsonb | YES |  |  |
| is_super_admin | boolean | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
| phone | text | YES | NULL::character varying |  |
| phone_confirmed_at | timestamp with time zone | YES |  |  |
| phone_change | text | YES | ''::character varying |  |
| phone_change_token | character varying | YES | ''::character varying |  |
| phone_change_sent_at | timestamp with time zone | YES |  |  |
| confirmed_at | timestamp with time zone | YES |  |  |
| email_change_token_current | character varying | YES | ''::character varying |  |
| email_change_confirm_status | smallint | YES | 0 |  |
| banned_until | timestamp with time zone | YES |  |  |
| reauthentication_token | character varying | YES | ''::character varying |  |
| reauthentication_sent_at | timestamp with time zone | YES |  |  |
| is_sso_user | boolean | NO | false | Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails. |
| deleted_at | timestamp with time zone | YES |  |  |
| is_anonymous | boolean | NO | false |  |
### Table: ai_settings
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| primary_provider | text | NO |  |  |
| fallback_provider | text | YES |  |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: artist_features
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| user_id | uuid | NO |  |  |
| feature_name | text | NO |  |  |
| enabled | boolean | YES | false |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
### Table: artwork_counts
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| profile_id | uuid | YES |  |  |
| artwork_count | bigint | YES |  |  |
### Table: artwork_embeddings
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| artwork_id | uuid | YES |  |  |
| embedding | USER-DEFINED | YES |  |  |
| embedding_type | text | NO |  |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: artwork_embeddings_gemini
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| artwork_id | uuid | YES |  |  |
| embedding_type | text | NO |  |  |
| embedding | USER-DEFINED | NO |  |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: artwork_favorites
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| user_id | uuid | NO |  |  |
| artwork_id | uuid | NO |  |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: artworks
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| artist_id | uuid | NO |  |  |
| title | text | NO |  |  |
| description | text | YES |  |  |
| price | numeric | YES |  |  |
| status | USER-DEFINED | NO | 'draft'::artwork_status |  |
| created_at | timestamp with time zone | YES | CURRENT_TIMESTAMP |  |
| updated_at | timestamp with time zone | YES | CURRENT_TIMESTAMP |  |
| images | jsonb | NO | '[]'::jsonb | Array of image objects with structure: { url: string, isPrimary: boolean, order: number } |
| styles | ARRAY | YES | '{}'::text[] |  |
| techniques | ARRAY | YES | '{}'::text[] |  |
| keywords | ARRAY | YES | '{}'::text[] |  |
| display_order | integer | YES |  |  |
| ai_generated | boolean | YES | false | Indicates if the artwork was generated by the MM AI system |
| ai_context | jsonb | YES |  | Stores the UnifiedAI context used to generate the artwork |
| analysis_results | ARRAY | YES |  | Stores array of analysis results from UnifiedAI system |
| ai_metadata | jsonb | YES | '{}'::jsonb | Additional metadata specific to AI-generated content |
| gallery_wall_type | USER-DEFINED | YES |  |  |
| gallery_price | numeric | YES |  |  |
| gallery_approved_at | timestamp with time zone | YES |  |  |
| gallery_approved_by | uuid | YES |  |  |
### Table: artworks_with_artist
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | YES |  |  |
| title | text | YES |  |  |
| description | text | YES |  |  |
| price | numeric | YES |  |  |
| status | USER-DEFINED | YES |  |  |
| images | jsonb | YES |  |  |
| display_order | integer | YES |  |  |
| created_at | timestamp with time zone | YES |  |  |
| updated_at | timestamp with time zone | YES |  |  |
| artist_id | uuid | YES |  |  |
| artist_name | text | YES |  |  |
| artist_full_name | text | YES |  |  |
| artist_bio | text | YES |  |  |
| artist_avatar_url | text | YES |  |  |
| artist_role | USER-DEFINED | YES |  |  |
### Table: chat_history
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| user_id | uuid | NO |  |  |
| assistant_type | text | NO |  |  |
| message | text | NO |  |  |
| response | text | NO |  |  |
| artwork_id | uuid | YES |  |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| context | jsonb | YES | '{}'::jsonb |  |
| message_embedding | USER-DEFINED | YES |  |  |
| response_embedding | USER-DEFINED | YES |  |  |
### Table: collection_items
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| collection_id | uuid | NO |  |  |
| artwork_id | uuid | NO |  |  |
| notes | text | YES |  |  |
| added_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| display_order | integer | YES | 0 |  |
| transaction_id | uuid | YES |  |  |
### Table: collection_views
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| collection_id | uuid | NO |  |  |
| viewer_id | uuid | YES |  |  |
| source | text | NO | 'direct'::text |  |
| referrer | text | YES |  |  |
| viewed_at | timestamp with time zone | NO | now() |  |
| created_at | timestamp with time zone | NO | now() |  |
### Table: collections
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| patron_id | uuid | YES |  |  |
| name | text | NO |  |  |
| description | text | YES |  |  |
| is_private | boolean | YES | false |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| is_purchased | boolean | YES | false |  |
| user_id | uuid | YES |  |  |
### Table: feature_usage
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| user_id | uuid | YES |  |  |
| feature_name | text | NO |  |  |
| usage_count | integer | YES | 0 |  |
| last_used_at | timestamp with time zone | YES |  |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: featured_artist
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| artist_id | uuid | NO |  |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| created_by | uuid | YES |  |  |
| active | boolean | YES | true |  |
### Table: follows
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| follower_id | uuid | NO |  |  |
| following_id | uuid | NO |  |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: gallery_dates
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| date | date | NO |  |  |
| is_available | boolean | YES | true |  |
| updated_by | uuid | YES |  |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: gallery_show_artworks
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| show_id | uuid | NO |  |  |
| artwork_id | uuid | NO |  |  |
### Table: gallery_shows
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| title | text | NO |  |  |
| start_date | timestamp with time zone | NO |  |  |
| end_date | timestamp with time zone | NO |  |  |
| status | text | NO | 'pending'::text |  |
| created_by | uuid | YES |  |  |
| approved_by | uuid | YES |  |  |
| approved_at | timestamp with time zone | YES |  |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: gallery_visits
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| user_id | uuid | NO |  |  |
| scanned_by | uuid | NO |  |  |
| visit_type | text | NO |  |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: ghost_profiles
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| email | text | NO |  |  |
| stripe_customer_id | text | YES |  | Stripe customer ID, can be null for guest checkouts |
| is_claimed | boolean | YES | false |  |
| display_name | text | YES | 'Art Collector'::text |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
| last_purchase_date | timestamp with time zone | YES |  |  |
| total_purchases | integer | YES | 0 |  |
| total_spent | integer | YES | 0 |  |
| is_visible | boolean | YES | false |  |
| claimed_profile_id | uuid | YES |  |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
### Table: notification_settings
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| user_id | uuid | YES |  |  |
| notification_type | USER-DEFINED | NO |  |  |
| enabled | boolean | YES | true |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: partial_registrations
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| email | text | NO |  |  |
| data | jsonb | NO | '{}'::jsonb |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| expires_at | timestamp with time zone | NO | timezone('utc'::text, (now() + '24:00:00'::interval)) |  |
### Table: profile_roles
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | YES |  |  |
| mapped_role | USER-DEFINED | YES |  |  |
| original_role | USER-DEFINED | YES |  |  |
### Table: profiles
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO |  |  |
| email | text | NO |  |  |
| name | text | YES |  |  |
| bio | text | YES |  |  |
| website | text | YES |  |  |
| instagram | text | YES |  |  |
| role | USER-DEFINED | YES | 'user'::user_role |  |
| artist_status | USER-DEFINED | YES |  |  |
| artist_application | jsonb | YES |  |  |
| artist_approved_at | timestamp with time zone | YES |  |  |
| artist_approved_by | uuid | YES |  |  |
| artist_rejection_reason | text | YES |  |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| last_notification_sent | timestamp with time zone | YES |  |  |
| last_notification_type | text | YES |  |  |
| stripe_account_id | text | YES |  |  |
| stripe_onboarding_complete | boolean | YES | false |  |
| first_name | text | YES |  | The user's first name and any middle names |
| last_name | text | YES |  | The user's last name/surname |
| full_name | text | YES |  |  |
| artist_type | text | YES |  |  |
| verification_requirements | jsonb | YES | jsonb_build_object('portfolio_complete', false, 'identity_verified', false, 'gallery_connection', false, 'sales_history', false, 'community_engagement', false) |  |
| verification_progress | integer | YES | 0 |  |
| view_count | integer | YES | 0 |  |
| exhibition_badge | boolean | YES | false |  |
| avatar_url | text | YES |  |  |
| location | text | YES |  | The location/city of the artist |
| community_engagement_score | integer | YES | 0 |  |
| verification_status | text | YES | 'pending'::text |  |
| verification_status_updated_at | timestamp with time zone | YES |  |  |
| medium | ARRAY | YES | ARRAY[]::text[] | Array of mediums the artist works with (e.g., ["oil", "acrylic", "digital"]) |
| total_purchases | integer | YES | 0 |  |
| total_spent | integer | YES | 0 |  |
| last_purchase_date | timestamp with time zone | YES |  |  |
| ghost_profile_claimed | boolean | YES | false |  |
### Table: role_conversions
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| user_id | uuid | YES |  |  |
| from_role | USER-DEFINED | YES |  |  |
| to_role | USER-DEFINED | YES |  |  |
| conversion_type | text | NO |  |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: store_orders
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| product_id | uuid | YES |  |  |
| ghost_profile_id | uuid | YES |  |  |
| amount_total | numeric | NO |  |  |
| artist_amount | numeric | NO |  |  |
| status | text | NO | 'pending'::text |  |
| stripe_session_id | text | YES |  |  |
| stripe_payment_intent | text | YES |  |  |
| shipping_details | jsonb | YES |  |  |
| customer_details | jsonb | YES |  |  |
| metadata | jsonb | YES |  |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: store_products
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| profile_id | uuid | YES |  |  |
| artwork_id | uuid | YES |  |  |
| stripe_product_id | text | YES |  |  |
| stripe_price_id | text | YES |  |  |
| is_variable_price | boolean | YES | false |  |
| min_price | numeric | YES |  |  |
| status | text | NO | 'draft'::text |  |
| metadata | jsonb | YES |  |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
| payment_link | text | YES |  |  |
| stripe_product_metadata | jsonb | YES |  |  |
| inventory_status | text | YES |  |  |
| payment_link_id | text | YES |  |  |
| payment_link_status | text | YES | 'active'::text |  |
### Table: store_settings
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| profile_id | uuid | NO |  |  |
| stripe_account_id | text | YES |  |  |
| is_stripe_enabled | boolean | YES | false |  |
| application_fee_percent | numeric | NO | 50.0 |  |
| metadata | jsonb | YES |  |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: store_transfers
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| artist_id | uuid | YES |  |  |
| order_id | uuid | YES |  |  |
| amount | numeric | NO |  |  |
| status | text | NO | 'pending'::text |  |
| stripe_session_id | text | YES |  |  |
| stripe_transfer_id | text | YES |  |  |
| metadata | jsonb | YES |  |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: text_embeddings
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| content_type | text | NO |  |  |
| content_id | uuid | NO |  |  |
| embedding | USER-DEFINED | YES |  |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: transactions
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| artwork_id | uuid | YES |  |  |
| buyer_id | uuid | YES |  |  |
| artist_id | uuid | YES |  |  |
| amount_total | integer | NO |  |  |
| platform_fee | integer | NO |  |  |
| artist_amount | integer | NO |  |  |
| stripe_payment_intent_id | text | YES |  |  |
| status | USER-DEFINED | NO |  |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
| ghost_profile_id | uuid | YES |  |  |
| payment_intent_status | text | YES |  |  |
| amount_received | integer | YES |  |  |
| capture_method | text | YES |  |  |
| confirmation_method | text | YES |  |  |
| description | text | YES |  |  |
| invoice_id | text | YES |  |  |
| statement_descriptor | text | YES |  |  |
| statement_descriptor_suffix | text | YES |  |  |
| payment_method_id | text | YES |  |  |
| payment_method_types | ARRAY | YES |  |  |
| payment_method_details | jsonb | YES |  |  |
| card_brand | text | YES |  |  |
| card_last4 | text | YES |  |  |
| card_exp_month | integer | YES |  |  |
| card_exp_year | integer | YES |  |  |
| card_country | text | YES |  |  |
| stripe_created | timestamp with time zone | YES |  |  |
| stripe_canceled_at | timestamp with time zone | YES |  |  |
| stripe_processing_at | timestamp with time zone | YES |  |  |
| stripe_succeeded_at | timestamp with time zone | YES |  |  |
| error_message | text | YES |  |  |
| error_code | text | YES |  |  |
| last_payment_error | jsonb | YES |  |  |
| payment_method_type | text | YES |  |  |
| billing_name | text | YES |  |  |
| billing_email | text | YES |  |  |
| billing_phone | text | YES |  |  |
| billing_address_line1 | text | YES |  |  |
| billing_address_line2 | text | YES |  |  |
| billing_address_city | text | YES |  |  |
| billing_address_state | text | YES |  |  |
| billing_address_postal_code | text | YES |  |  |
| billing_address_country | text | YES |  |  |
| refunded | boolean | YES | false |  |
| refund_status | text | YES |  |  |
| refund_reason | text | YES |  |  |
| is_gallery_entry | boolean | YES | false |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
### Table: user_events
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| user_id | uuid | YES |  |  |
| session_id | text | YES |  |  |
| event_type | text | NO |  |  |
| event_name | text | NO |  |  |
| event_data | jsonb | YES | '{}'::jsonb |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: user_preferences
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | uuid_generate_v4() |  |
| user_id | uuid | YES |  |  |
| theme | USER-DEFINED | YES | 'system'::theme_preference |  |
| ai_personality | USER-DEFINED | YES | 'HAL9000'::ai_personality |  |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
### Table: user_sessions
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| user_id | uuid | YES |  |  |
| session_id | text | NO |  |  |
| started_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| ended_at | timestamp with time zone | YES |  |  |
| metadata | jsonb | YES | '{}'::jsonb |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: verification_progress
Schema: public

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| user_id | uuid | NO |  |  |
| current_step | text | NO |  |  |
| steps_completed | ARRAY | YES | '{}'::text[] |  |
| next_steps | ARRAY | YES | '{}'::text[] |  |
| requirements_met | jsonb | YES | '{}'::jsonb |  |
| feedback | text | YES |  |  |
| reviewer_id | uuid | YES |  |  |
| created_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
| updated_at | timestamp with time zone | NO | timezone('utc'::text, now()) |  |
### Table: buckets
Schema: storage

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | text | NO |  |  |
| name | text | NO |  |  |
| owner | uuid | YES |  | Field is deprecated, use owner_id instead |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
| public | boolean | YES | false |  |
| avif_autodetection | boolean | YES | false |  |
| file_size_limit | bigint | YES |  |  |
| allowed_mime_types | ARRAY | YES |  |  |
| owner_id | text | YES |  |  |
### Table: migrations
Schema: storage

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | integer | NO |  |  |
| name | character varying | NO |  |  |
| hash | character varying | NO |  |  |
| executed_at | timestamp without time zone | YES | CURRENT_TIMESTAMP |  |
### Table: objects
Schema: storage

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| bucket_id | text | YES |  |  |
| name | text | YES |  |  |
| owner | uuid | YES |  | Field is deprecated, use owner_id instead |
| created_at | timestamp with time zone | YES | now() |  |
| updated_at | timestamp with time zone | YES | now() |  |
| last_accessed_at | timestamp with time zone | YES | now() |  |
| metadata | jsonb | YES |  |  |
| path_tokens | ARRAY | YES |  |  |
| version | text | YES |  |  |
| owner_id | text | YES |  |  |
| user_metadata | jsonb | YES |  |  |
### Table: s3_multipart_uploads
Schema: storage

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | text | NO |  |  |
| in_progress_size | bigint | NO | 0 |  |
| upload_signature | text | NO |  |  |
| bucket_id | text | NO |  |  |
| key | text | NO |  |  |
| version | text | NO |  |  |
| owner_id | text | YES |  |  |
| created_at | timestamp with time zone | NO | now() |  |
| user_metadata | jsonb | YES |  |  |
### Table: s3_multipart_uploads_parts
Schema: storage

| Column | Type | Nullable | Default | Description |
|--------|------|----------|----------|--------------|
| id | uuid | NO | gen_random_uuid() |  |
| upload_id | text | NO |  |  |
| size | bigint | NO | 0 |  |
| part_number | integer | NO |  |  |
| bucket_id | text | NO |  |  |
| key | text | NO |  |  |
| etag | text | NO |  |  |
| owner_id | text | YES |  |  |
| version | text | NO |  |  |
| created_at | timestamp with time zone | NO | now() |  |
```


## Foreign Key Relationships

```sql
- auth.identities.user_id -> auth.users.id
- auth.mfa_amr_claims.session_id -> auth.sessions.id
- auth.mfa_challenges.factor_id -> auth.mfa_factors.id
- auth.mfa_factors.user_id -> auth.users.id
- auth.one_time_tokens.user_id -> auth.users.id
- auth.refresh_tokens.session_id -> auth.sessions.id
- auth.saml_providers.sso_provider_id -> auth.sso_providers.id
- auth.saml_relay_states.flow_state_id -> auth.flow_state.id
- auth.saml_relay_states.sso_provider_id -> auth.sso_providers.id
- auth.sessions.user_id -> auth.users.id
- auth.sso_domains.sso_provider_id -> auth.sso_providers.id
- public.artist_features.user_id -> public.profiles.id
- public.artwork_embeddings.artwork_id -> public.artworks.id
- public.artwork_embeddings_gemini.artwork_id -> public.artworks.id
- public.artwork_favorites.artwork_id -> public.artworks.id
- public.artworks.artist_id -> public.profiles.id
- public.artworks.gallery_approved_by -> public.profiles.id
- public.chat_history.artwork_id -> public.artworks.id
- public.collection_items.transaction_id -> public.transactions.id
- public.collection_items.collection_id -> public.collections.id
- public.collection_items.artwork_id -> public.artworks.id
- public.collection_views.collection_id -> public.collections.id
- public.collections.patron_id -> public.profiles.id
- public.feature_usage.user_id -> public.profiles.id
- public.featured_artist.artist_id -> public.profiles.id
- public.featured_artist.created_by -> public.profiles.id
- public.gallery_dates.updated_by -> public.profiles.id
- public.gallery_show_artworks.artwork_id -> public.artworks.id
- public.gallery_show_artworks.show_id -> public.gallery_shows.id
- public.gallery_shows.created_by -> public.profiles.id
- public.gallery_shows.approved_by -> public.profiles.id
- public.gallery_visits.scanned_by -> public.profiles.id
- public.gallery_visits.user_id -> public.profiles.id
- public.ghost_profiles.claimed_profile_id -> public.profiles.id
- public.role_conversions.user_id -> public.profiles.id
- public.store_orders.ghost_profile_id -> public.ghost_profiles.id
- public.store_orders.product_id -> public.store_products.id
- public.store_products.profile_id -> public.profiles.id
- public.store_products.artwork_id -> public.artworks.id
- public.store_settings.profile_id -> public.profiles.id
- public.store_transfers.order_id -> public.store_orders.id
- public.store_transfers.artist_id -> public.profiles.id
- public.transactions.ghost_profile_id -> public.ghost_profiles.id
- public.transactions.artwork_id -> public.artworks.id
- public.user_events.user_id -> public.profiles.id
- public.user_events.session_id -> public.user_sessions.session_id
- public.user_sessions.user_id -> public.profiles.id
- public.verification_progress.user_id -> public.profiles.id
- public.verification_progress.reviewer_id -> public.profiles.id
- storage.objects.bucket_id -> storage.buckets.id
- storage.s3_multipart_uploads.bucket_id -> storage.buckets.id
- storage.s3_multipart_uploads_parts.bucket_id -> storage.buckets.id
- storage.s3_multipart_uploads_parts.upload_id -> storage.s3_multipart_uploads.id
```


## RLS Policies

```sql
### Table: ai_settings

- Policy: Allow admin users to update settings
  - Roles: {authenticated}
  - Command: ALL
  - Definition: ((auth.jwt() ->> 'role'::text) = 'admin'::text)
  - With Check: ((auth.jwt() ->> 'role'::text) = 'admin'::text)

- Policy: Allow read access to all authenticated users
  - Roles: {authenticated}
  - Command: SELECT
  - Definition: true


### Table: artist_features

- Policy: Users can view their own features
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() = user_id)

- Policy: Admins can modify features
  - Roles: {public}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))


### Table: artwork_embeddings

- Policy: System can manage artwork embeddings
  - Roles: {public}
  - Command: ALL
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))

- Policy: Anyone can view artwork embeddings for published artworks
  - Roles: {public}
  - Command: SELECT
  - Definition: (artwork_id IN ( SELECT artworks.id
   FROM artworks
  WHERE (artworks.status = 'published'::artwork_status)))

- Policy: Artists can view own artwork embeddings
  - Roles: {public}
  - Command: SELECT
  - Definition: (artwork_id IN ( SELECT artworks.id
   FROM artworks
  WHERE (artworks.artist_id = auth.uid())))


### Table: artwork_embeddings_gemini

- Policy: Enable insert for authenticated users only
  - Roles: {authenticated}
  - Command: INSERT
  - Definition: true

- Policy: Enable update for authenticated users only
  - Roles: {authenticated}
  - Command: UPDATE
  - Definition: true

- Policy: Enable read access for all users
  - Roles: {public}
  - Command: SELECT
  - Definition: true


### Table: artwork_favorites

- Policy: Users can manage their favorites
  - Roles: {public}
  - Command: ALL
  - Definition: (auth.uid() = user_id)
  - With Check: (auth.uid() = user_id)

- Policy: Users can see artwork favorites
  - Roles: {public}
  - Command: SELECT
  - Definition: ((auth.uid() = user_id) OR (EXISTS ( SELECT 1
   FROM artworks
  WHERE ((artworks.id = artwork_favorites.artwork_id) AND (artworks.status = 'published'::artwork_status)))))


### Table: artworks

- Policy: Artists can update their own artworks
  - Roles: {public}
  - Command: UPDATE
  - Definition: ((auth.uid() = artist_id) AND (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND is_artist(profiles.role)))))

- Policy: Artists can update own artworks
  - Roles: {public}
  - Command: UPDATE
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.id = artworks.artist_id)))

- Policy: Anyone can view AI-generated artworks
  - Roles: {public}
  - Command: SELECT
  - Definition: (((status = 'published'::artwork_status) AND (ai_generated = true)) OR (auth.uid() = artist_id) OR (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role)))))

- Policy: Anyone can view published artworks
  - Roles: {public}
  - Command: SELECT
  - Definition: (status = 'published'::artwork_status)

- Policy: Artists can delete own artworks
  - Roles: {public}
  - Command: DELETE
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.id = artworks.artist_id)))

- Policy: Artists can create artworks
  - Roles: {public}
  - Command: INSERT
  - Definition: ((auth.uid() = artist_id) AND (EXISTS ( SELECT 1
   FROM profiles p
  WHERE ((p.id = auth.uid()) AND ((p.role = 'emerging_artist'::user_role) OR (p.role = 'verified_artist'::user_role))))))

- Policy: Artists can view own artworks
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.id = artworks.artist_id)))


### Table: collection_items

- Policy: collection_items_modify
  - Roles: {public}
  - Command: ALL
  - Definition: (collection_id IN ( SELECT collections.id
   FROM collections
  WHERE (collections.patron_id = auth.uid())))

- Policy: collection_items_access
  - Roles: {public}
  - Command: SELECT
  - Definition: (collection_id IN ( SELECT collections.id
   FROM collections
  WHERE ((collections.patron_id = auth.uid()) OR ((NOT collections.is_private) AND (collections.patron_id IN ( SELECT profiles.id
           FROM profiles
          WHERE (profiles.role = 'patron'::user_role)))))))


### Table: collection_views

- Policy: Anyone can insert collection views
  - Roles: {public}
  - Command: INSERT
  - Definition: true

- Policy: Collection owners can view analytics
  - Roles: {public}
  - Command: SELECT
  - Definition: (EXISTS ( SELECT 1
   FROM collections c
  WHERE ((c.id = collection_views.collection_id) AND (c.user_id = auth.uid()))))


### Table: collections

- Policy: Users can delete their own collections
  - Roles: {public}
  - Command: DELETE
  - Definition: (patron_id = auth.uid())

- Policy: patron_collection_access
  - Roles: {public}
  - Command: SELECT
  - Definition: ((patron_id = auth.uid()) OR ((NOT is_private) AND (patron_id IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'patron'::user_role)))))

- Policy: patron_collection_delete
  - Roles: {public}
  - Command: DELETE
  - Definition: (patron_id = auth.uid())

- Policy: patron_collection_update
  - Roles: {public}
  - Command: UPDATE
  - Definition: (patron_id = auth.uid())

- Policy: patron_collection_insert
  - Roles: {public}
  - Command: INSERT
  - Definition: (auth.uid() IS NOT NULL)

- Policy: Users can insert their own collections
  - Roles: {public}
  - Command: INSERT
  - Definition: (patron_id = auth.uid())

- Policy: Users can update their own collections
  - Roles: {public}
  - Command: UPDATE
  - Definition: (patron_id = auth.uid())
  - With Check: (patron_id = auth.uid())


### Table: feature_usage

- Policy: Admins can view all feature usage
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))

- Policy: Users can create and update their own feature usage
  - Roles: {public}
  - Command: ALL
  - Definition: (auth.uid() = user_id)
  - With Check: (auth.uid() = user_id)

- Policy: Users can view their own feature usage
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() = user_id)


### Table: featured_artist

- Policy: Allow public to view featured artists
  - Roles: {anon,authenticated}
  - Command: SELECT
  - Definition: true

- Policy: Allow admins to manage featured artists
  - Roles: {authenticated}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))
  - With Check: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))


### Table: follows

- Policy: Users can follow artists
  - Roles: {public}
  - Command: INSERT
  - Definition: ((auth.uid() = follower_id) AND (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = follows.following_id) AND is_artist(profiles.role)))))

- Policy: Users can see their follow relationships
  - Roles: {public}
  - Command: SELECT
  - Definition: ((auth.uid() = follower_id) OR (auth.uid() = following_id) OR (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = follows.following_id) AND is_artist(profiles.role)))))

- Policy: Users can unfollow artists
  - Roles: {public}
  - Command: DELETE
  - Definition: ((auth.uid() = follower_id) AND (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = follows.following_id) AND is_artist(profiles.role)))))

- Policy: Users can manage their follows
  - Roles: {public}
  - Command: ALL
  - Definition: (auth.uid() = follower_id)
  - With Check: (auth.uid() = follower_id)


### Table: gallery_dates

- Policy: admin_dates_update
  - Roles: {authenticated}
  - Command: UPDATE
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))
  - With Check: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))

- Policy: admin_dates
  - Roles: {authenticated}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))

- Policy: admin_dates_insert
  - Roles: {authenticated}
  - Command: INSERT
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))

- Policy: view_dates
  - Roles: {authenticated}
  - Command: SELECT
  - Definition: true


### Table: gallery_show_artworks

- Policy: artist_show_artworks
  - Roles: {authenticated}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM gallery_shows
  WHERE ((gallery_shows.id = gallery_show_artworks.show_id) AND ((gallery_shows.created_by = auth.uid()) OR (EXISTS ( SELECT 1
           FROM profiles
          WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['artist'::user_role, 'verified_artist'::user_role])) AND (profiles.exhibition_badge = true))))))))

- Policy: admin_show_artworks
  - Roles: {authenticated}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))


### Table: gallery_shows

- Policy: admin_gallery_manage
  - Roles: {authenticated}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))

- Policy: artist_gallery_shows
  - Roles: {authenticated}
  - Command: ALL
  - Definition: ((created_by = auth.uid()) OR (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['artist'::user_role, 'verified_artist'::user_role])) AND (profiles.exhibition_badge = true)))))


### Table: gallery_visits

- Policy: Users can view their own visits and visits they've scanned
  - Roles: {public}
  - Command: SELECT
  - Definition: ((auth.uid() = user_id) OR (auth.uid() = scanned_by))

- Policy: Authenticated users can create visits
  - Roles: {public}
  - Command: INSERT
  - Definition: (auth.role() = 'authenticated'::text)


### Table: ghost_profiles

- Policy: user_view_own_unclaimed
  - Roles: {public}
  - Command: SELECT
  - Definition: ((auth.jwt() IS NOT NULL) AND (is_claimed = false) AND (email = (auth.jwt() ->> 'email'::text)))

- Policy: Admins have full access to ghost profiles
  - Roles: {public}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))
  - With Check: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))

- Policy: Admin service role has full access
  - Roles: {public}
  - Command: ALL
  - Definition: (current_setting('role'::text) = 'service_role'::text)
  - With Check: (current_setting('role'::text) = 'service_role'::text)

- Policy: Artists can view purchaser profiles
  - Roles: {public}
  - Command: SELECT
  - Definition: (EXISTS ( SELECT 1
   FROM (transactions t
     JOIN artworks a ON ((t.artwork_id = a.id)))
  WHERE ((t.ghost_profile_id = ghost_profiles.id) AND (a.artist_id = auth.uid()))))

- Policy: user_view_claimed
  - Roles: {public}
  - Command: SELECT
  - Definition: ((auth.jwt() IS NOT NULL) AND (is_claimed = true) AND (claimed_profile_id = auth.uid()))

- Policy: service_role_full_access
  - Roles: {public}
  - Command: ALL
  - Definition: (current_setting('role'::text) = 'service_role'::text)
  - With Check: (current_setting('role'::text) = 'service_role'::text)

- Policy: ghost_profile_access
  - Roles: {authenticated}
  - Command: SELECT
  - Definition: ((claimed_profile_id = auth.uid()) OR (is_visible = true) OR (email = (( SELECT users.email
   FROM auth.users
  WHERE (users.id = auth.uid())
 LIMIT 1))::text))

- Policy: Service role has full access
  - Roles: {public}
  - Command: ALL
  - Definition: (current_setting('role'::text) = 'service_role'::text)
  - With Check: (current_setting('role'::text) = 'service_role'::text)

- Policy: Public can view visible profiles
  - Roles: {public}
  - Command: SELECT
  - Definition: (is_visible = true)


### Table: notification_settings

- Policy: Users can insert own notification settings
  - Roles: {public}
  - Command: INSERT
  - Definition: (auth.uid() = user_id)

- Policy: Users can view own notification settings
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() = user_id)

- Policy: Users can update own notification settings
  - Roles: {public}
  - Command: UPDATE
  - Definition: (auth.uid() = user_id)


### Table: partial_registrations

- Policy: Users can update their own partial registrations
  - Roles: {public}
  - Command: UPDATE
  - Definition: (email = CURRENT_USER)
  - With Check: (email = CURRENT_USER)

- Policy: Users can delete their own partial registrations
  - Roles: {public}
  - Command: DELETE
  - Definition: (email = CURRENT_USER)

- Policy: Anyone can create partial registrations
  - Roles: {public}
  - Command: INSERT
  - Definition: true

- Policy: Users can view their own partial registrations
  - Roles: {public}
  - Command: SELECT
  - Definition: (email = CURRENT_USER)


### Table: profiles

- Policy: Users can update own profile
  - Roles: {public}
  - Command: UPDATE
  - Definition: (auth.uid() = id)

- Policy: Only admins can update roles
  - Roles: {public}
  - Command: UPDATE
  - Definition: (auth.uid() IN ( SELECT profiles_1.id
   FROM profiles profiles_1
  WHERE (profiles_1.role = 'admin'::user_role)))
  - With Check: (auth.uid() IN ( SELECT profiles_1.id
   FROM profiles profiles_1
  WHERE (profiles_1.role = 'admin'::user_role)))

- Policy: Patrons can update their own profiles
  - Roles: {public}
  - Command: UPDATE
  - Definition: ((auth.uid() = id) AND (is_patron((auth.role())::user_role) OR is_artist((auth.role())::user_role)))

- Policy: Public profiles are viewable by everyone
  - Roles: {public}
  - Command: SELECT
  - Definition: true

- Policy: Profiles are viewable by everyone
  - Roles: {public}
  - Command: SELECT
  - Definition: true


### Table: role_conversions

- Policy: System can manage role conversions
  - Roles: {public}
  - Command: ALL
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))

- Policy: Admins can view all role conversions
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))

- Policy: Users can view their own role conversions
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() = user_id)


### Table: store_orders

- Policy: Admins can view all orders
  - Roles: {public}
  - Command: SELECT
  - Definition: (EXISTS ( SELECT 1
   FROM profile_roles
  WHERE ((profile_roles.id = auth.uid()) AND (profile_roles.mapped_role = 'admin'::user_role))))

- Policy: Artists can view their own orders
  - Roles: {public}
  - Command: SELECT
  - Definition: (EXISTS ( SELECT 1
   FROM store_products
  WHERE ((store_products.id = store_orders.product_id) AND (store_products.profile_id = auth.uid()))))


### Table: store_products

- Policy: Verified artists can manage their own products
  - Roles: {public}
  - Command: ALL
  - Definition: ((auth.uid() = profile_id) AND (EXISTS ( SELECT 1
   FROM profile_roles
  WHERE ((profile_roles.id = auth.uid()) AND (profile_roles.mapped_role = 'verified_artist'::user_role)))))

- Policy: Admins can manage all products
  - Roles: {public}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profile_roles
  WHERE ((profile_roles.id = auth.uid()) AND (profile_roles.mapped_role = 'admin'::user_role))))

- Policy: Anyone can view products
  - Roles: {public}
  - Command: SELECT
  - Definition: true


### Table: store_settings

- Policy: Users can view their own store settings
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() = profile_id)

- Policy: Verified artists can manage their store settings
  - Roles: {public}
  - Command: ALL
  - Definition: ((auth.uid() = profile_id) AND (EXISTS ( SELECT 1
   FROM profile_roles
  WHERE ((profile_roles.id = auth.uid()) AND (profile_roles.mapped_role = 'verified_artist'::user_role)))))

- Policy: Admins can manage all store settings
  - Roles: {public}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profile_roles
  WHERE ((profile_roles.id = auth.uid()) AND (profile_roles.mapped_role = 'admin'::user_role))))


### Table: store_transfers

- Policy: Artists can view their transfers
  - Roles: {public}
  - Command: SELECT
  - Definition: (artist_id = auth.uid())

- Policy: Admins can manage transfers
  - Roles: {public}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profile_roles
  WHERE ((profile_roles.id = auth.uid()) AND (profile_roles.mapped_role = 'admin'::user_role))))


### Table: text_embeddings

- Policy: Anyone can view public text embeddings
  - Roles: {public}
  - Command: SELECT
  - Definition: (content_type = ANY (ARRAY['public_content'::text, 'artwork_description'::text]))

- Policy: Users can view own text embeddings
  - Roles: {public}
  - Command: SELECT
  - Definition: (((content_id)::text = (auth.uid())::text) OR (content_id IN ( SELECT artworks.id
   FROM artworks
  WHERE (artworks.artist_id = auth.uid()))))

- Policy: System can manage text embeddings
  - Roles: {public}
  - Command: ALL
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))


### Table: transactions

- Policy: transaction_access
  - Roles: {public}
  - Command: SELECT
  - Definition: ((buyer_id = auth.uid()) OR (artist_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM ghost_profiles
  WHERE ((ghost_profiles.id = transactions.ghost_profile_id) AND ((ghost_profiles.claimed_profile_id = auth.uid()) OR (ghost_profiles.email = (auth.jwt() ->> 'email'::text)))))) OR (EXISTS ( SELECT 1
   FROM collection_items ci
  WHERE ((ci.transaction_id = transactions.id) AND (ci.collection_id IN ( SELECT collections.id
           FROM collections
          WHERE (collections.patron_id = auth.uid())))))))

- Policy: System can insert transactions
  - Roles: {public}
  - Command: INSERT
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))

- Policy: Ghost profiles can view their transactions
  - Roles: {public}
  - Command: SELECT
  - Definition: (ghost_profile_id IN ( SELECT ghost_profiles.id
   FROM ghost_profiles
  WHERE (ghost_profiles.stripe_customer_id = current_setting('stripe.customer_id'::text, true))))

- Policy: Admins can view all transactions
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))


### Table: user_events

- Policy: Admins can view all events
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))

- Policy: Users can create their own events
  - Roles: {public}
  - Command: INSERT
  - Definition: (auth.uid() = user_id)

- Policy: Users can view their own events
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() = user_id)


### Table: user_preferences

- Policy: Users can update own preferences
  - Roles: {public}
  - Command: UPDATE
  - Definition: (auth.uid() = user_id)

- Policy: Users can view own preferences
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() = user_id)

- Policy: Users can insert own preferences
  - Roles: {public}
  - Command: INSERT
  - Definition: (auth.uid() = user_id)


### Table: user_sessions

- Policy: Users can view their own sessions
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() = user_id)

- Policy: Users can update their own sessions
  - Roles: {public}
  - Command: UPDATE
  - Definition: (auth.uid() = user_id)
  - With Check: (auth.uid() = user_id)

- Policy: Users can create their own sessions
  - Roles: {public}
  - Command: INSERT
  - Definition: (auth.uid() = user_id)

- Policy: Admins can view all sessions
  - Roles: {public}
  - Command: SELECT
  - Definition: (auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.role = 'admin'::user_role)))


### Table: verification_progress

- Policy: Admins and profile owner can view verification progress
  - Roles: {public}
  - Command: SELECT
  - Definition: ((auth.uid() = user_id) OR (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role)))))

- Policy: Admins can modify verification progress
  - Roles: {public}
  - Command: ALL
  - Definition: (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role))))


```


## Functions

```sql
### Function: add_artwork_to_collection

`sql
CREATE OR REPLACE FUNCTION public.add_artwork_to_collection()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

  -- Only process successful transactions for direct user purchases

  IF NEW.status = 'succeeded' AND NEW.buyer_id IS NOT NULL AND NEW.ghost_profile_id IS NULL THEN

    -- Get or create purchased works collection

    WITH collection_creation AS (

      INSERT INTO collections (

        name,

        description,

        patron_id,

        is_purchased,

        is_private

      )

      SELECT 

        'Purchased Works',

        'Your collection of purchased artworks',

        NEW.buyer_id,

        true,

        false

      WHERE NOT EXISTS (

        SELECT 1 FROM collections 

        WHERE patron_id = NEW.buyer_id 

        AND is_purchased = true

      )

      RETURNING id

    )

    -- Insert into collection_items

    INSERT INTO collection_items (

      collection_id,

      artwork_id,

      transaction_id,

      added_at,

      display_order,

      notes

    )

    SELECT 

      COALESCE(

        (SELECT id FROM collection_creation),

        (SELECT id FROM collections WHERE patron_id = NEW.buyer_id AND is_purchased = true)

      ),

      NEW.artwork_id,

      NEW.id,

      NEW.created_at,

      COALESCE((

        SELECT MAX(display_order) + 1 

        FROM collection_items 

        WHERE collection_id = (

          SELECT id FROM collections 

          WHERE patron_id = NEW.buyer_id 

          AND is_purchased = true

        )

      ), 0),

      'Purchased on ' || NEW.created_at::date;

  END IF;

  RETURN NEW;

END;

$function$

`

### Function: approve_gallery_show

`sql
CREATE OR REPLACE FUNCTION public.approve_gallery_show(p_show_id uuid, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone)
 RETURNS SETOF gallery_shows
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Start transaction
  BEGIN
    -- Update show status
    UPDATE gallery_shows
    SET 
      status = 'approved',
      approved_at = NOW(),
      approved_by = p_user_id
    WHERE id = p_show_id;

    -- Insert dates as unavailable for the show duration
    WITH RECURSIVE dates AS (
      SELECT p_start_date::date AS date
      UNION ALL
      SELECT (date + interval '1 day')::date
      FROM dates
      WHERE date < p_end_date::date
    )
    INSERT INTO gallery_dates (date, is_available, updated_at, updated_by)
    SELECT 
      date,
      false AS is_available,
      NOW() AS updated_at,
      p_user_id AS updated_by
    FROM dates
    ON CONFLICT (date) DO UPDATE
    SET 
      is_available = false,
      updated_at = NOW(),
      updated_by = p_user_id;

    -- Return the updated show
    RETURN QUERY
    SELECT *
    FROM gallery_shows
    WHERE id = p_show_id;

    -- Commit transaction
    COMMIT;
  EXCEPTION WHEN OTHERS THEN
    -- Rollback transaction on error
    ROLLBACK;
    RAISE;
  END;
END;
$function$

`

### Function: array_to_halfvec

`sql
CREATE OR REPLACE FUNCTION public.array_to_halfvec(integer[], integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_halfvec$function$

`

### Function: array_to_halfvec

`sql
CREATE OR REPLACE FUNCTION public.array_to_halfvec(real[], integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_halfvec$function$

`

### Function: array_to_halfvec

`sql
CREATE OR REPLACE FUNCTION public.array_to_halfvec(double precision[], integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_halfvec$function$

`

### Function: array_to_halfvec

`sql
CREATE OR REPLACE FUNCTION public.array_to_halfvec(numeric[], integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_halfvec$function$

`

### Function: array_to_sparsevec

`sql
CREATE OR REPLACE FUNCTION public.array_to_sparsevec(real[], integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_sparsevec$function$

`

### Function: array_to_sparsevec

`sql
CREATE OR REPLACE FUNCTION public.array_to_sparsevec(numeric[], integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_sparsevec$function$

`

### Function: array_to_sparsevec

`sql
CREATE OR REPLACE FUNCTION public.array_to_sparsevec(integer[], integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_sparsevec$function$

`

### Function: array_to_sparsevec

`sql
CREATE OR REPLACE FUNCTION public.array_to_sparsevec(double precision[], integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_sparsevec$function$

`

### Function: array_to_vector

`sql
CREATE OR REPLACE FUNCTION public.array_to_vector(numeric[], integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_vector$function$

`

### Function: array_to_vector

`sql
CREATE OR REPLACE FUNCTION public.array_to_vector(double precision[], integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_vector$function$

`

### Function: array_to_vector

`sql
CREATE OR REPLACE FUNCTION public.array_to_vector(real[], integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_vector$function$

`

### Function: array_to_vector

`sql
CREATE OR REPLACE FUNCTION public.array_to_vector(integer[], integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$array_to_vector$function$

`

### Function: binary_quantize

`sql
CREATE OR REPLACE FUNCTION public.binary_quantize(halfvec)
 RETURNS bit
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_binary_quantize$function$

`

### Function: binary_quantize

`sql
CREATE OR REPLACE FUNCTION public.binary_quantize(vector)
 RETURNS bit
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$binary_quantize$function$

`

### Function: calculate_engagement_score

`sql
CREATE OR REPLACE FUNCTION public.calculate_engagement_score(target_user_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$

DECLARE

    follower_count integer;

    profile_view_count integer;

    favorite_count integer;

    gallery_visit_count integer;

    total_score integer;

BEGIN

    -- Get follower count

    SELECT COUNT(*) INTO follower_count

    FROM follows

    WHERE following_id = target_user_id;



    -- Get profile views (explicitly reference profiles table)

    SELECT COALESCE(profiles.view_count, 0) INTO profile_view_count

    FROM profiles

    WHERE profiles.id = target_user_id;



    -- Get artwork favorites

    SELECT COUNT(*) INTO favorite_count

    FROM artwork_favorites af

    JOIN artworks a ON a.id = af.artwork_id

    WHERE a.artist_id = target_user_id;



    -- Get gallery visits (explicitly reference gallery_visits table)

    SELECT COUNT(*) INTO gallery_visit_count

    FROM gallery_visits gv

    WHERE gv.user_id = target_user_id;



    -- Calculate total score

    total_score := (follower_count * 2) +

                   (profile_view_count * 0.5)::integer +

                   (favorite_count * 1) +

                   (gallery_visit_count * 5);



    RETURN total_score;

END;

$function$

`

### Function: calculate_verification_progress

`sql
CREATE OR REPLACE FUNCTION public.calculate_verification_progress()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

  NEW.verification_progress := (

    (CASE WHEN (NEW.verification_requirements->>'portfolio_complete')::boolean THEN 20 ELSE 0 END) +

    (CASE WHEN (NEW.verification_requirements->>'identity_verified')::boolean THEN 20 ELSE 0 END) +

    (CASE WHEN (NEW.verification_requirements->>'gallery_connection')::boolean THEN 20 ELSE 0 END) +

    (CASE WHEN (NEW.verification_requirements->>'sales_history')::boolean THEN 20 ELSE 0 END) +

    (CASE WHEN (NEW.verification_requirements->>'community_engagement')::boolean THEN 20 ELSE 0 END)

  );

  RETURN NEW;

END;

$function$

`

### Function: check_engagement_verification

`sql
CREATE OR REPLACE FUNCTION public.check_engagement_verification()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

DECLARE

  completed_count INTEGER;

  total_count INTEGER;

BEGIN

  -- If engagement score reaches threshold (50), update verification requirements

  IF NEW.community_engagement_score >= 50 AND 

     (OLD.community_engagement_score IS NULL OR OLD.community_engagement_score < 50) THEN

    

    -- Update the verification requirements

    NEW.verification_requirements = jsonb_set(

      COALESCE(NEW.verification_requirements, '{}'::jsonb),

      '{platform_engagement,hasCommunityEngagement}',

      'true'

    );

    

    -- Calculate completed requirements

    SELECT 

      COUNT(*) FILTER (WHERE value = 'true'),

      COUNT(*)

    INTO completed_count, total_count

    FROM jsonb_each_text(NEW.verification_requirements);

    

    -- Update verification progress

    IF total_count > 0 THEN

      NEW.verification_progress := FLOOR((completed_count::float / total_count::float) * 100);

    ELSE

      NEW.verification_progress := 0;

    END IF;

  END IF;

  

  RETURN NEW;

END;

$function$

`

### Function: claim_ghost_profile

`sql
CREATE OR REPLACE FUNCTION public.claim_ghost_profile(ghost_profile_id uuid, claiming_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$

DECLARE

  collection_id uuid;

BEGIN

  -- Update ghost profile

  UPDATE ghost_profiles

  SET 

    is_claimed = true,

    claimed_profile_id = claiming_user_id,

    metadata = jsonb_set(

      COALESCE(metadata, '{}'::jsonb),

      '{claimed_at}',

      to_jsonb(now()::text)

    )

  WHERE id = ghost_profile_id;



  -- Update transactions with hybrid approach

  UPDATE transactions

  SET 

    buyer_id = claiming_user_id,

    metadata = jsonb_set(

      COALESCE(metadata, '{}'::jsonb),

      '{claiming_history}',

      jsonb_build_object(

        'claimed_at', now(),

        'original_ghost_profile_id', ghost_profile_id

      )

    )

  WHERE ghost_profile_id = ghost_profile_id

  AND buyer_id IS NULL;



  -- Create purchased works collection if it doesn't exist

  INSERT INTO collections (

    name,

    description,

    patron_id,

    is_purchased,

    is_private

  )

  SELECT 

    'Purchased Works',

    'Your collection of purchased artworks',

    claiming_user_id,

    true,

    false

  WHERE NOT EXISTS (

    SELECT 1 FROM collections 

    WHERE patron_id = claiming_user_id 

    AND is_purchased = true

  )

  RETURNING id INTO collection_id;



  -- If collection already exists, get its id

  IF collection_id IS NULL THEN

    SELECT id INTO collection_id

    FROM collections

    WHERE patron_id = claiming_user_id

    AND is_purchased = true;

  END IF;



  -- Add purchased artworks to collection

  INSERT INTO collection_items (

    collection_id,

    artwork_id,

    transaction_id,

    notes,

    added_at,

    display_order

  )

  SELECT 

    collection_id,

    t.artwork_id,

    t.id,

    'Purchased on ' || t.created_at::date,

    t.created_at,

    ROW_NUMBER() OVER (ORDER BY t.created_at) - 1

  FROM transactions t

  WHERE t.ghost_profile_id = ghost_profile_id

  AND t.status = 'succeeded'

  AND t.artwork_id IS NOT NULL

  AND NOT EXISTS (

    SELECT 1 FROM collection_items 

    WHERE transaction_id = t.id

  );

END;

$function$

`

### Function: cleanup_expired_registrations

`sql
CREATE OR REPLACE FUNCTION public.cleanup_expired_registrations()
 RETURNS void
 LANGUAGE plpgsql
AS $function$

BEGIN

    DELETE FROM public.partial_registrations

    WHERE expires_at < timezone('utc'::text, now());

END;

$function$

`

### Function: cosine_distance

`sql
CREATE OR REPLACE FUNCTION public.cosine_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$cosine_distance$function$

`

### Function: cosine_distance

`sql
CREATE OR REPLACE FUNCTION public.cosine_distance(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_cosine_distance$function$

`

### Function: cosine_distance

`sql
CREATE OR REPLACE FUNCTION public.cosine_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_cosine_distance$function$

`

### Function: create_store_product

`sql
CREATE OR REPLACE FUNCTION public.create_store_product(_profile_id uuid, _artwork_id uuid, _stripe_product_id text, _stripe_price_id text, _payment_link text, _stripe_product_metadata jsonb, _is_variable_price boolean DEFAULT false, _min_price numeric DEFAULT NULL::numeric)
 RETURNS store_products
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$

declare

  _product store_products;

begin

  -- Verify the artwork belongs to the artist

  if not exists (

    select 1 from artworks

    where id = _artwork_id

    and artist_id = _profile_id

  ) then

    raise exception 'Artwork does not belong to artist';

  end if;



  insert into store_products (

    profile_id,

    artwork_id,

    stripe_product_id,

    stripe_price_id,

    payment_link,

    stripe_product_metadata,

    is_variable_price,

    min_price

  )

  values (

    _profile_id,

    _artwork_id,

    _stripe_product_id,

    _stripe_price_id,

    _payment_link,

    _stripe_product_metadata,

    _is_variable_price,

    _min_price

  )

  returning * into _product;



  return _product;

end;

$function$

`

### Function: create_store_product

`sql
CREATE OR REPLACE FUNCTION public.create_store_product(_profile_id uuid, _artwork_id uuid, _stripe_product_id text, _stripe_price_id text, _is_variable_price boolean DEFAULT false, _min_price numeric DEFAULT NULL::numeric)
 RETURNS store_products
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$

declare

  _product store_products;

begin

  -- Verify the artwork belongs to the artist

  if not exists (

    select 1 from artworks

    where id = _artwork_id

    and artist_id = _profile_id

  ) then

    raise exception 'Artwork does not belong to artist';

  end if;



  insert into store_products (

    profile_id,

    artwork_id,

    stripe_product_id,

    stripe_price_id,

    is_variable_price,

    min_price

  )

  values (

    _profile_id,

    _artwork_id,

    _stripe_product_id,

    _stripe_price_id,

    _is_variable_price,

    _min_price

  )

  returning * into _product;



  return _product;

end;

$function$

`

### Function: find_artwork_conversations

`sql
CREATE OR REPLACE FUNCTION public.find_artwork_conversations(p_user_id uuid, p_artwork_id uuid, p_match_count integer DEFAULT 5)
 RETURNS TABLE(id uuid, message text, response text, created_at timestamp with time zone, metadata jsonb, context jsonb)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$

    select 

        id,

        message,

        response,

        created_at,

        metadata,

        context

    from chat_history

    where user_id = p_user_id

    and artwork_id = p_artwork_id

    order by created_at desc

    limit p_match_count;

$function$

`

### Function: find_similar_conversations

`sql
CREATE OR REPLACE FUNCTION public.find_similar_conversations(p_user_id uuid, p_query text, p_embedding vector, p_match_count integer DEFAULT 5, p_match_threshold double precision DEFAULT 0.8)
 RETURNS TABLE(id uuid, message text, response text, similarity double precision)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$

    select 

        id,

        message,

        response,

        1 - (message_embedding <=> p_embedding) as similarity

    from chat_history

    where user_id = p_user_id 

    and 1 - (message_embedding <=> p_embedding) > p_match_threshold

    order by message_embedding <=> p_embedding

    limit p_match_count;

$function$

`

### Function: get_collection_stats

`sql
CREATE OR REPLACE FUNCTION public.get_collection_stats(collection_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  result jsonb;
BEGIN
  SELECT jsonb_build_object(
    'total_value', COALESCE(SUM(t.amount_total), 0),
    'average_price', COALESCE(AVG(t.amount_total), 0),
    'unique_artists', COUNT(DISTINCT a.artist_id),
    'days_since_last_purchase', EXTRACT(DAY FROM (NOW() - MAX(t.created_at)))::integer,
    'ghost_purchases', COUNT(DISTINCT t.ghost_profile_id),
    'direct_purchases', COUNT(DISTINCT t.buyer_id)
  ) INTO result
  FROM collection_items ci
  INNER JOIN transactions t ON t.id = ci.transaction_id
  INNER JOIN artworks a ON a.id = ci.artwork_id
  WHERE ci.collection_id = $1
  AND t.status = 'succeeded';

  RETURN result;
END;
$function$

`

### Function: get_user_settings

`sql
CREATE OR REPLACE FUNCTION public.get_user_settings(p_user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$

DECLARE

    result JSON;

    user_role text;

BEGIN

    -- First get the user's role

    SELECT role INTO user_role

    FROM profiles

    WHERE id::UUID = p_user_id;



    SELECT json_build_object(

        'preferences', COALESCE(

            (

                SELECT json_build_object(

                    'theme', theme,

                    'aiPersonality', ai_personality

                )

                FROM user_preferences

                WHERE user_id = p_user_id

            ),

            json_build_object(

                'theme', 'system'::theme_preference,

                'aiPersonality', 'HAL9000'::ai_personality

            )

        ),

        'notifications', COALESCE(

            (

                SELECT json_object_agg(notification_type, enabled)

                FROM notification_settings

                WHERE user_id = p_user_id

            ),

            json_build_object(

                'email', true,

                'new_artwork', true,

                'new_follower', true,

                'artwork_favorited', true,

                'price_alert', true

            )

        ),

        'role', (

            SELECT json_build_object(

                'current', role,

                -- Only include artist fields for artist roles

                'medium', CASE 

                    WHEN role IN ('artist', 'emerging_artist', 'verified_artist') 

                    THEN COALESCE(medium, ARRAY[]::text[])

                    ELSE ARRAY[]::text[]

                END,

                'artist_type', CASE 

                    WHEN role IN ('artist', 'emerging_artist', 'verified_artist') 

                    THEN artist_type 

                    ELSE 'none'::text

                END,

                'artist_status', CASE 

                    WHEN role IN ('artist', 'emerging_artist', 'verified_artist') 

                    THEN COALESCE(artist_status, 'draft')::text

                    ELSE 'draft'::text

                END

            )

            FROM profiles

            WHERE id::UUID = p_user_id

        )

    ) INTO result;



    RETURN result;

END;

$function$

`

### Function: halfvec

`sql
CREATE OR REPLACE FUNCTION public.halfvec(halfvec, integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec$function$

`

### Function: halfvec_accum

`sql
CREATE OR REPLACE FUNCTION public.halfvec_accum(double precision[], halfvec)
 RETURNS double precision[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_accum$function$

`

### Function: halfvec_add

`sql
CREATE OR REPLACE FUNCTION public.halfvec_add(halfvec, halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_add$function$

`

### Function: halfvec_avg

`sql
CREATE OR REPLACE FUNCTION public.halfvec_avg(double precision[])
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_avg$function$

`

### Function: halfvec_cmp

`sql
CREATE OR REPLACE FUNCTION public.halfvec_cmp(halfvec, halfvec)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_cmp$function$

`

### Function: halfvec_combine

`sql
CREATE OR REPLACE FUNCTION public.halfvec_combine(double precision[], double precision[])
 RETURNS double precision[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_combine$function$

`

### Function: halfvec_concat

`sql
CREATE OR REPLACE FUNCTION public.halfvec_concat(halfvec, halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_concat$function$

`

### Function: halfvec_eq

`sql
CREATE OR REPLACE FUNCTION public.halfvec_eq(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_eq$function$

`

### Function: halfvec_ge

`sql
CREATE OR REPLACE FUNCTION public.halfvec_ge(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_ge$function$

`

### Function: halfvec_gt

`sql
CREATE OR REPLACE FUNCTION public.halfvec_gt(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_gt$function$

`

### Function: halfvec_in

`sql
CREATE OR REPLACE FUNCTION public.halfvec_in(cstring, oid, integer)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_in$function$

`

### Function: halfvec_l2_squared_distance

`sql
CREATE OR REPLACE FUNCTION public.halfvec_l2_squared_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l2_squared_distance$function$

`

### Function: halfvec_le

`sql
CREATE OR REPLACE FUNCTION public.halfvec_le(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_le$function$

`

### Function: halfvec_lt

`sql
CREATE OR REPLACE FUNCTION public.halfvec_lt(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_lt$function$

`

### Function: halfvec_mul

`sql
CREATE OR REPLACE FUNCTION public.halfvec_mul(halfvec, halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_mul$function$

`

### Function: halfvec_ne

`sql
CREATE OR REPLACE FUNCTION public.halfvec_ne(halfvec, halfvec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_ne$function$

`

### Function: halfvec_negative_inner_product

`sql
CREATE OR REPLACE FUNCTION public.halfvec_negative_inner_product(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_negative_inner_product$function$

`

### Function: halfvec_out

`sql
CREATE OR REPLACE FUNCTION public.halfvec_out(halfvec)
 RETURNS cstring
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_out$function$

`

### Function: halfvec_recv

`sql
CREATE OR REPLACE FUNCTION public.halfvec_recv(internal, oid, integer)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_recv$function$

`

### Function: halfvec_send

`sql
CREATE OR REPLACE FUNCTION public.halfvec_send(halfvec)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_send$function$

`

### Function: halfvec_spherical_distance

`sql
CREATE OR REPLACE FUNCTION public.halfvec_spherical_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_spherical_distance$function$

`

### Function: halfvec_sub

`sql
CREATE OR REPLACE FUNCTION public.halfvec_sub(halfvec, halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_sub$function$

`

### Function: halfvec_to_float4

`sql
CREATE OR REPLACE FUNCTION public.halfvec_to_float4(halfvec, integer, boolean)
 RETURNS real[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_to_float4$function$

`

### Function: halfvec_to_sparsevec

`sql
CREATE OR REPLACE FUNCTION public.halfvec_to_sparsevec(halfvec, integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_to_sparsevec$function$

`

### Function: halfvec_to_vector

`sql
CREATE OR REPLACE FUNCTION public.halfvec_to_vector(halfvec, integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_to_vector$function$

`

### Function: halfvec_typmod_in

`sql
CREATE OR REPLACE FUNCTION public.halfvec_typmod_in(cstring[])
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_typmod_in$function$

`

### Function: hamming_distance

`sql
CREATE OR REPLACE FUNCTION public.hamming_distance(bit, bit)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$hamming_distance$function$

`

### Function: handle_artwork_favorite

`sql
CREATE OR REPLACE FUNCTION public.handle_artwork_favorite()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$

BEGIN

    IF (TG_OP = 'DELETE') THEN

        UPDATE public.artworks

        SET updated_at = NOW()

        WHERE id = OLD.artwork_id;

        RETURN OLD;

    ELSIF (TG_OP = 'INSERT') THEN

        UPDATE public.artworks

        SET updated_at = NOW()

        WHERE id = NEW.artwork_id;

        RETURN NEW;

    END IF;

    RETURN NULL;

END;

$function$

`

### Function: handle_artwork_purchase

`sql
CREATE OR REPLACE FUNCTION public.handle_artwork_purchase()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

DECLARE

  purchase_collection_id UUID;

BEGIN

  -- Get or create the "Purchased Works" collection for this patron

  SELECT id INTO purchase_collection_id

  FROM collections

  WHERE patron_id = NEW.buyer_id 

    AND is_purchased = true

  LIMIT 1;



  IF purchase_collection_id IS NULL THEN

    INSERT INTO collections (

      name,

      description,

      patron_id,

      is_purchased,

      is_private

    ) VALUES (

      'Purchased Works',

      'Your collection of purchased artworks',

      NEW.buyer_id,

      true,

      false

    ) RETURNING id INTO purchase_collection_id;

  END IF;



  -- Add the purchased artwork to the collection

  INSERT INTO collection_items (

    collection_id,

    artwork_id,

    notes

  ) VALUES (

    purchase_collection_id,

    NEW.artwork_id,

    'Purchased on ' || NEW.created_at::date

  );



  RETURN NEW;

END;

$function$

`

### Function: handle_new_user

`sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$

begin

  insert into public.profiles (id, email)

  values (new.id, new.email);

  return new;

end;

$function$

`

### Function: handle_new_user_follow

`sql
CREATE OR REPLACE FUNCTION public.handle_new_user_follow()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    mm_ai_id uuid := '00000000-0000-4000-a000-000000000001';
BEGIN
    -- Create follow relationship
    INSERT INTO public.follows (
        follower_id,
        following_id,
        created_at,
        updated_at
    )
    VALUES (
        NEW.id,
        mm_ai_id,
        NOW(),
        NOW()
    )
    ON CONFLICT (follower_id, following_id) DO NOTHING;
    
    RETURN NEW;
END;
$function$

`

### Function: handle_updated_at

`sql
CREATE OR REPLACE FUNCTION public.handle_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

    NEW.updated_at = timezone('utc'::text, now());

    RETURN NEW;

END;

$function$

`

### Function: hnsw_bit_support

`sql
CREATE OR REPLACE FUNCTION public.hnsw_bit_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$hnsw_bit_support$function$

`

### Function: hnsw_halfvec_support

`sql
CREATE OR REPLACE FUNCTION public.hnsw_halfvec_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$hnsw_halfvec_support$function$

`

### Function: hnsw_sparsevec_support

`sql
CREATE OR REPLACE FUNCTION public.hnsw_sparsevec_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$hnsw_sparsevec_support$function$

`

### Function: hnswhandler

`sql
CREATE OR REPLACE FUNCTION public.hnswhandler(internal)
 RETURNS index_am_handler
 LANGUAGE c
AS '$libdir/vector', $function$hnswhandler$function$

`

### Function: inner_product

`sql
CREATE OR REPLACE FUNCTION public.inner_product(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_inner_product$function$

`

### Function: inner_product

`sql
CREATE OR REPLACE FUNCTION public.inner_product(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$inner_product$function$

`

### Function: inner_product

`sql
CREATE OR REPLACE FUNCTION public.inner_product(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_inner_product$function$

`

### Function: is_artist

`sql
CREATE OR REPLACE FUNCTION public.is_artist(role_to_check user_role)
 RETURNS boolean
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE
AS $function$

  SELECT role_to_check::text IN ('artist', 'verified_artist', 'emerging_artist');

$function$

`

### Function: is_patron

`sql
CREATE OR REPLACE FUNCTION public.is_patron(role_to_check user_role)
 RETURNS boolean
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE
AS $function$

  SELECT role_to_check::text = 'patron';

$function$

`

### Function: ivfflat_bit_support

`sql
CREATE OR REPLACE FUNCTION public.ivfflat_bit_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$ivfflat_bit_support$function$

`

### Function: ivfflat_halfvec_support

`sql
CREATE OR REPLACE FUNCTION public.ivfflat_halfvec_support(internal)
 RETURNS internal
 LANGUAGE c
AS '$libdir/vector', $function$ivfflat_halfvec_support$function$

`

### Function: ivfflathandler

`sql
CREATE OR REPLACE FUNCTION public.ivfflathandler(internal)
 RETURNS index_am_handler
 LANGUAGE c
AS '$libdir/vector', $function$ivfflathandler$function$

`

### Function: jaccard_distance

`sql
CREATE OR REPLACE FUNCTION public.jaccard_distance(bit, bit)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$jaccard_distance$function$

`

### Function: l1_distance

`sql
CREATE OR REPLACE FUNCTION public.l1_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$l1_distance$function$

`

### Function: l1_distance

`sql
CREATE OR REPLACE FUNCTION public.l1_distance(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l1_distance$function$

`

### Function: l1_distance

`sql
CREATE OR REPLACE FUNCTION public.l1_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l1_distance$function$

`

### Function: l2_distance

`sql
CREATE OR REPLACE FUNCTION public.l2_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$l2_distance$function$

`

### Function: l2_distance

`sql
CREATE OR REPLACE FUNCTION public.l2_distance(halfvec, halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l2_distance$function$

`

### Function: l2_distance

`sql
CREATE OR REPLACE FUNCTION public.l2_distance(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l2_distance$function$

`

### Function: l2_norm

`sql
CREATE OR REPLACE FUNCTION public.l2_norm(sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l2_norm$function$

`

### Function: l2_norm

`sql
CREATE OR REPLACE FUNCTION public.l2_norm(halfvec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l2_norm$function$

`

### Function: l2_normalize

`sql
CREATE OR REPLACE FUNCTION public.l2_normalize(sparsevec)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l2_normalize$function$

`

### Function: l2_normalize

`sql
CREATE OR REPLACE FUNCTION public.l2_normalize(halfvec)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_l2_normalize$function$

`

### Function: l2_normalize

`sql
CREATE OR REPLACE FUNCTION public.l2_normalize(vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$l2_normalize$function$

`

### Function: match_artworks

`sql
CREATE OR REPLACE FUNCTION public.match_artworks(query_embedding vector, match_threshold double precision, match_count integer)
 RETURNS TABLE(id uuid, artwork_id uuid, similarity double precision)
 LANGUAGE plpgsql
AS $function$

BEGIN

    RETURN QUERY

    SELECT

        artwork_embeddings.id,

        artwork_embeddings.artwork_id,

        1 - (artwork_embeddings.embedding <=> query_embedding) AS similarity

    FROM artwork_embeddings

    WHERE 1 - (artwork_embeddings.embedding <=> query_embedding) > match_threshold

    ORDER BY artwork_embeddings.embedding <=> query_embedding

    LIMIT match_count;

END;

$function$

`

### Function: match_artworks_gemini

`sql
CREATE OR REPLACE FUNCTION public.match_artworks_gemini(query_embedding vector, match_threshold double precision DEFAULT 0.1, match_count integer DEFAULT 10)
 RETURNS TABLE(id uuid, artwork_id uuid, similarity double precision)
 LANGUAGE plpgsql
AS $function$

BEGIN

  RETURN QUERY

  SELECT

    ae.id,

    ae.artwork_id,

    1 - (ae.embedding <=> query_embedding) as similarity

  FROM artwork_embeddings_gemini ae

  WHERE 1 - (ae.embedding <=> query_embedding) > match_threshold

  ORDER BY ae.embedding <=> query_embedding

  LIMIT match_count;

END;

$function$

`

### Function: move_collection_items

`sql
CREATE OR REPLACE FUNCTION public.move_collection_items(p_source_collection_id uuid, p_target_collection_id uuid, p_artwork_ids uuid[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$

BEGIN

  -- Insert items into target collection

  INSERT INTO collection_items (collection_id, artwork_id)

  SELECT p_target_collection_id, unnest(p_artwork_ids);



  -- Remove items from source collection

  DELETE FROM collection_items

  WHERE collection_id = p_source_collection_id

  AND artwork_id = ANY(p_artwork_ids);

END;

$function$

`

### Function: revert_claimed_ghost_profile

`sql
CREATE OR REPLACE FUNCTION public.revert_claimed_ghost_profile(target_ghost_profile_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$

DECLARE

  claimed_user_id uuid;

  collection_ids uuid[];

BEGIN

  -- Get the claimed user ID

  SELECT claimed_profile_id INTO claimed_user_id

  FROM ghost_profiles

  WHERE id = target_ghost_profile_id;



  -- Get collection IDs associated with the user

  SELECT array_agg(id) INTO collection_ids

  FROM collections

  WHERE patron_id = claimed_user_id;



  -- Delete collection items first (due to foreign key constraints)

  DELETE FROM collection_items

  WHERE collection_id = ANY(collection_ids);



  -- Delete collections

  DELETE FROM collections

  WHERE patron_id = claimed_user_id;



  -- Revert transactions back to ghost profile only

  UPDATE transactions

  SET 

    buyer_id = NULL,

    metadata = metadata - 'claiming_history'

  WHERE ghost_profile_id = target_ghost_profile_id;



  -- Reset ghost profile to unclaimed state

  UPDATE ghost_profiles

  SET 

    is_claimed = false,

    claimed_profile_id = NULL,

    metadata = metadata - 'claimed_at'

  WHERE id = target_ghost_profile_id;

END;

$function$

`

### Function: search_profiles

`sql
CREATE OR REPLACE FUNCTION public.search_profiles(search_query text)
 RETURNS TABLE(id uuid, rank real, full_name text, bio text, location text)
 LANGUAGE plpgsql
AS $function$

BEGIN

  RETURN QUERY

  SELECT

    p.id,

    ts_rank(to_tsvector('english', coalesce(p.bio, '')), plainto_tsquery(search_query)) +

    ts_rank(to_tsvector('english', coalesce(p.full_name, '')), plainto_tsquery(search_query)) +

    ts_rank(to_tsvector('english', coalesce(p.location, '')), plainto_tsquery(search_query)) as rank,

    p.full_name,

    p.bio,

    p.location

  FROM public.profiles p

  WHERE

    to_tsvector('english', coalesce(p.bio, '')) @@ plainto_tsquery(search_query) OR

    to_tsvector('english', coalesce(p.full_name, '')) @@ plainto_tsquery(search_query) OR

    to_tsvector('english', coalesce(p.location, '')) @@ plainto_tsquery(search_query)

  ORDER BY rank DESC;

END;

$function$

`

### Function: send_email

`sql
CREATE OR REPLACE FUNCTION public.send_email(recipient text, subject text, content text, sender text DEFAULT 'noreply@meaningmachine.com'::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$

BEGIN

  -- Log the email request

  RAISE NOTICE 'Email request - To: %, Subject: %, From: %', recipient, subject, sender;

  

  -- In production, emails will be sent through Supabase's Email service

  -- This function now just serves as a logging wrapper

  RETURN json_build_object('success', true);

EXCEPTION

  WHEN OTHERS THEN

    RAISE NOTICE 'Error processing email request: %', SQLERRM;

    RETURN json_build_object('success', false, 'error', SQLERRM);

END;

$function$

`

### Function: set_featured_artist

`sql
CREATE OR REPLACE FUNCTION public.set_featured_artist(artist_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    new_featured_id uuid;
BEGIN
    -- Check if user is admin
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles
        WHERE id = auth.uid()
        AND role = 'admin'::user_role
    ) THEN
        RAISE EXCEPTION 'Only admins can set featured artists';
    END IF;

    -- Deactivate current featured artist if exists
    UPDATE public.featured_artist
    SET active = false
    WHERE active = true;

    -- Insert new featured artist
    INSERT INTO public.featured_artist (artist_id, created_by)
    VALUES (artist_id, auth.uid())
    RETURNING id INTO new_featured_id;

    RETURN new_featured_id;
END;
$function$

`

### Function: set_stripe_status_timestamp

`sql
CREATE OR REPLACE FUNCTION public.set_stripe_status_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

  IF NEW.status != OLD.status THEN

    CASE NEW.status

      WHEN 'succeeded' THEN

        NEW.stripe_succeeded_at = NOW();

      WHEN 'processing' THEN

        NEW.stripe_processing_at = NOW();

      WHEN 'canceled' THEN

        NEW.stripe_canceled_at = NOW();

    END CASE;

  END IF;

  RETURN NEW;

END;

$function$

`

### Function: set_stripe_timestamps

`sql
CREATE OR REPLACE FUNCTION public.set_stripe_timestamps()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

  IF TG_OP = 'INSERT' OR NEW.status != OLD.status THEN

    NEW.updated_at := NOW();

  END IF;

  RETURN NEW;

END;

$function$

`

### Function: sparsevec

`sql
CREATE OR REPLACE FUNCTION public.sparsevec(sparsevec, integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec$function$

`

### Function: sparsevec_cmp

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_cmp(sparsevec, sparsevec)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_cmp$function$

`

### Function: sparsevec_eq

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_eq(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_eq$function$

`

### Function: sparsevec_ge

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_ge(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_ge$function$

`

### Function: sparsevec_gt

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_gt(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_gt$function$

`

### Function: sparsevec_in

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_in(cstring, oid, integer)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_in$function$

`

### Function: sparsevec_l2_squared_distance

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_l2_squared_distance(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_l2_squared_distance$function$

`

### Function: sparsevec_le

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_le(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_le$function$

`

### Function: sparsevec_lt

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_lt(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_lt$function$

`

### Function: sparsevec_ne

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_ne(sparsevec, sparsevec)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_ne$function$

`

### Function: sparsevec_negative_inner_product

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_negative_inner_product(sparsevec, sparsevec)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_negative_inner_product$function$

`

### Function: sparsevec_out

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_out(sparsevec)
 RETURNS cstring
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_out$function$

`

### Function: sparsevec_recv

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_recv(internal, oid, integer)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_recv$function$

`

### Function: sparsevec_send

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_send(sparsevec)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_send$function$

`

### Function: sparsevec_to_halfvec

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_to_halfvec(sparsevec, integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_to_halfvec$function$

`

### Function: sparsevec_to_vector

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_to_vector(sparsevec, integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_to_vector$function$

`

### Function: sparsevec_typmod_in

`sql
CREATE OR REPLACE FUNCTION public.sparsevec_typmod_in(cstring[])
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$sparsevec_typmod_in$function$

`

### Function: split_name

`sql
CREATE OR REPLACE FUNCTION public.split_name(name text)
 RETURNS TABLE(first_name text, last_name text)
 LANGUAGE plpgsql
AS $function$

DECLARE

    name_parts text[];

BEGIN

    -- Handle NULL or empty string

    IF name IS NULL OR name = '' THEN

        RETURN QUERY SELECT NULL::text, NULL::text;

        RETURN;

    END IF;

    

    -- Split the name into parts

    name_parts := regexp_split_to_array(trim(name), '\s+');

    

    -- If only one part, it's the first name

    IF array_length(name_parts, 1) = 1 THEN

        RETURN QUERY SELECT name_parts[1], NULL::text;

        RETURN;

    END IF;

    

    -- Last element is last name, everything else is first name

    RETURN QUERY SELECT 

        array_to_string(name_parts[1:array_length(name_parts, 1)-1], ' '),

        name_parts[array_length(name_parts, 1)];

END;

$function$

`

### Function: subvector

`sql
CREATE OR REPLACE FUNCTION public.subvector(halfvec, integer, integer)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_subvector$function$

`

### Function: subvector

`sql
CREATE OR REPLACE FUNCTION public.subvector(vector, integer, integer)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$subvector$function$

`

### Function: sync_full_name

`sql
CREATE OR REPLACE FUNCTION public.sync_full_name()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

    -- When first_name or last_name is updated

    IF TG_OP = 'UPDATE' THEN

        -- Construct full name from parts

        NEW.full_name := TRIM(COALESCE(NEW.first_name, '') || ' ' || COALESCE(NEW.last_name, ''));

    END IF;

    RETURN NEW;

END;

$function$

`

### Function: sync_name

`sql
CREATE OR REPLACE FUNCTION public.sync_name()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

    -- When first_name or last_name is updated

    IF TG_OP = 'UPDATE' THEN

        -- Construct name from parts

        NEW.name := TRIM(COALESCE(NEW.first_name, '') || ' ' || COALESCE(NEW.last_name, ''));

    END IF;

    RETURN NEW;

END;

$function$

`

### Function: update_ai_settings_updated_at

`sql
CREATE OR REPLACE FUNCTION public.update_ai_settings_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

begin

  new.updated_at = timezone('utc'::text, now());

  return new;

end;

$function$

`

### Function: update_artwork_order

`sql
CREATE OR REPLACE FUNCTION public.update_artwork_order(p_artwork_ids uuid[], p_artist_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$

begin

  -- Update the order of each artwork

  for i in 1..array_length(p_artwork_ids, 1)

  loop

    update artworks

    set display_order = i - 1

    where id = p_artwork_ids[i]

    and artist_id = p_artist_id;

  end loop;

end;

$function$

`

### Function: update_gallery_show_dates

`sql
CREATE OR REPLACE FUNCTION public.update_gallery_show_dates(p_show_id uuid, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone)
 RETURNS SETOF gallery_shows
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$

DECLARE

  v_old_start_date TIMESTAMP WITH TIME ZONE;

  v_old_end_date TIMESTAMP WITH TIME ZONE;

  v_show_status TEXT;

BEGIN

  -- Get the current show details

  SELECT start_date, end_date, status

  INTO v_old_start_date, v_old_end_date, v_show_status

  FROM gallery_shows

  WHERE id = p_show_id;



  IF NOT FOUND THEN

    RAISE EXCEPTION 'Show not found';

  END IF;



  -- Only handle date updates for approved shows

  IF v_show_status = 'approved' THEN

    -- Check for date conflicts with other approved shows

    IF EXISTS (

      SELECT 1

      FROM gallery_shows

      WHERE status = 'approved'

        AND id != p_show_id

        AND (

          (start_date, end_date) OVERLAPS (p_start_date, p_end_date)

        )

    ) THEN

      RAISE EXCEPTION 'Show dates conflict with existing approved shows';

    END IF;



    -- Start transaction

    BEGIN

      -- Update show dates

      UPDATE gallery_shows

      SET 

        start_date = p_start_date,

        end_date = p_end_date,

        updated_at = NOW()

      WHERE id = p_show_id;



      -- Free up old dates

      WITH RECURSIVE old_dates AS (

        SELECT v_old_start_date::date AS date

        UNION ALL

        SELECT (date + interval '1 day')::date

        FROM old_dates

        WHERE date < v_old_end_date::date

      )

      UPDATE gallery_dates

      SET 

        is_available = true,

        updated_at = NOW(),

        updated_by = p_user_id

      FROM old_dates

      WHERE gallery_dates.date = old_dates.date;



      -- Block new dates

      WITH RECURSIVE new_dates AS (

        SELECT p_start_date::date AS date

        UNION ALL

        SELECT (date + interval '1 day')::date

        FROM new_dates

        WHERE date < p_end_date::date

      )

      INSERT INTO gallery_dates (date, is_available, updated_at, updated_by)

      SELECT 

        date,

        false AS is_available,

        NOW() AS updated_at,

        p_user_id AS updated_by

      FROM new_dates

      ON CONFLICT (date) DO UPDATE

      SET 

        is_available = false,

        updated_at = NOW(),

        updated_by = p_user_id;



      -- Return the updated show

      RETURN QUERY

      SELECT *

      FROM gallery_shows

      WHERE id = p_show_id;



      -- Commit transaction

      COMMIT;

    EXCEPTION WHEN OTHERS THEN

      -- Rollback transaction on error

      ROLLBACK;

      RAISE;

    END;

  ELSE

    -- For non-approved shows, just update the dates without managing gallery_dates

    UPDATE gallery_shows

    SET 

      start_date = p_start_date,

      end_date = p_end_date,

      updated_at = NOW()

    WHERE id = p_show_id;



    RETURN QUERY

    SELECT *

    FROM gallery_shows

    WHERE id = p_show_id;

  END IF;

END;

$function$

`

### Function: update_ghost_profile_totals

`sql
CREATE OR REPLACE FUNCTION public.update_ghost_profile_totals()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

  IF NEW.status = 'succeeded' AND NEW.ghost_profile_id IS NOT NULL THEN

    UPDATE ghost_profiles

    SET 

      total_purchases = total_purchases + 1,

      total_spent = total_spent + NEW.amount_total,

      last_purchase_date = NEW.created_at

    WHERE id = NEW.ghost_profile_id;

  END IF;

  RETURN NEW;

END;

$function$

`

### Function: update_profile_engagement_score

`sql
CREATE OR REPLACE FUNCTION public.update_profile_engagement_score()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

DECLARE

    target_user_id UUID;

BEGIN

    -- Determine which user's score to update based on the operation

    IF TG_OP = 'INSERT' THEN

        CASE TG_TABLE_NAME

            WHEN 'follows' THEN

                target_user_id := NEW.following_id;

            WHEN 'artwork_favorites' THEN

                SELECT artist_id INTO target_user_id

                FROM artworks

                WHERE id = NEW.artwork_id;

            WHEN 'gallery_visits' THEN

                target_user_id := NEW.user_id;

        END CASE;

    ELSIF TG_OP = 'DELETE' THEN

        CASE TG_TABLE_NAME

            WHEN 'follows' THEN

                target_user_id := OLD.following_id;

            WHEN 'artwork_favorites' THEN

                SELECT artist_id INTO target_user_id

                FROM artworks

                WHERE id = OLD.artwork_id;

        END CASE;

    END IF;



    -- Update the profile with the new engagement score

    UPDATE profiles

    SET 

        community_engagement_score = calculate_engagement_score(target_user_id),

        updated_at = now()

    WHERE id = target_user_id;



    RETURN NULL;

END;

$function$

`

### Function: update_updated_at_column

`sql
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

    NEW.updated_at = NOW();

    RETURN NEW;

END;

$function$

`

### Function: update_verification_status_timestamp

`sql
CREATE OR REPLACE FUNCTION public.update_verification_status_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$

BEGIN

    NEW.verification_status_updated_at = NOW();

    RETURN NEW;

END;

$function$

`

### Function: upsert_user_preferences

`sql
CREATE OR REPLACE FUNCTION public.upsert_user_preferences(p_user_id uuid, p_theme theme_preference, p_ai_personality ai_personality DEFAULT 'HAL9000'::ai_personality)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$

BEGIN

    INSERT INTO user_preferences (user_id, theme, ai_personality)

    VALUES (p_user_id, p_theme, p_ai_personality)

    ON CONFLICT (user_id)

    DO UPDATE SET

        theme = EXCLUDED.theme,

        ai_personality = EXCLUDED.ai_personality,

        updated_at = NOW();

END;

$function$

`

### Function: vector

`sql
CREATE OR REPLACE FUNCTION public.vector(vector, integer, boolean)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector$function$

`

### Function: vector_accum

`sql
CREATE OR REPLACE FUNCTION public.vector_accum(double precision[], vector)
 RETURNS double precision[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_accum$function$

`

### Function: vector_add

`sql
CREATE OR REPLACE FUNCTION public.vector_add(vector, vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_add$function$

`

### Function: vector_avg

`sql
CREATE OR REPLACE FUNCTION public.vector_avg(double precision[])
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_avg$function$

`

### Function: vector_cmp

`sql
CREATE OR REPLACE FUNCTION public.vector_cmp(vector, vector)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_cmp$function$

`

### Function: vector_combine

`sql
CREATE OR REPLACE FUNCTION public.vector_combine(double precision[], double precision[])
 RETURNS double precision[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_combine$function$

`

### Function: vector_concat

`sql
CREATE OR REPLACE FUNCTION public.vector_concat(vector, vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_concat$function$

`

### Function: vector_dims

`sql
CREATE OR REPLACE FUNCTION public.vector_dims(vector)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_dims$function$

`

### Function: vector_dims

`sql
CREATE OR REPLACE FUNCTION public.vector_dims(halfvec)
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$halfvec_vector_dims$function$

`

### Function: vector_eq

`sql
CREATE OR REPLACE FUNCTION public.vector_eq(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_eq$function$

`

### Function: vector_ge

`sql
CREATE OR REPLACE FUNCTION public.vector_ge(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_ge$function$

`

### Function: vector_gt

`sql
CREATE OR REPLACE FUNCTION public.vector_gt(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_gt$function$

`

### Function: vector_in

`sql
CREATE OR REPLACE FUNCTION public.vector_in(cstring, oid, integer)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_in$function$

`

### Function: vector_l2_squared_distance

`sql
CREATE OR REPLACE FUNCTION public.vector_l2_squared_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_l2_squared_distance$function$

`

### Function: vector_le

`sql
CREATE OR REPLACE FUNCTION public.vector_le(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_le$function$

`

### Function: vector_lt

`sql
CREATE OR REPLACE FUNCTION public.vector_lt(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_lt$function$

`

### Function: vector_mul

`sql
CREATE OR REPLACE FUNCTION public.vector_mul(vector, vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_mul$function$

`

### Function: vector_ne

`sql
CREATE OR REPLACE FUNCTION public.vector_ne(vector, vector)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_ne$function$

`

### Function: vector_negative_inner_product

`sql
CREATE OR REPLACE FUNCTION public.vector_negative_inner_product(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_negative_inner_product$function$

`

### Function: vector_norm

`sql
CREATE OR REPLACE FUNCTION public.vector_norm(vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_norm$function$

`

### Function: vector_out

`sql
CREATE OR REPLACE FUNCTION public.vector_out(vector)
 RETURNS cstring
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_out$function$

`

### Function: vector_recv

`sql
CREATE OR REPLACE FUNCTION public.vector_recv(internal, oid, integer)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_recv$function$

`

### Function: vector_send

`sql
CREATE OR REPLACE FUNCTION public.vector_send(vector)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_send$function$

`

### Function: vector_spherical_distance

`sql
CREATE OR REPLACE FUNCTION public.vector_spherical_distance(vector, vector)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_spherical_distance$function$

`

### Function: vector_sub

`sql
CREATE OR REPLACE FUNCTION public.vector_sub(vector, vector)
 RETURNS vector
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_sub$function$

`

### Function: vector_to_float4

`sql
CREATE OR REPLACE FUNCTION public.vector_to_float4(vector, integer, boolean)
 RETURNS real[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_to_float4$function$

`

### Function: vector_to_halfvec

`sql
CREATE OR REPLACE FUNCTION public.vector_to_halfvec(vector, integer, boolean)
 RETURNS halfvec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_to_halfvec$function$

`

### Function: vector_to_sparsevec

`sql
CREATE OR REPLACE FUNCTION public.vector_to_sparsevec(vector, integer, boolean)
 RETURNS sparsevec
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_to_sparsevec$function$

`

### Function: vector_typmod_in

`sql
CREATE OR REPLACE FUNCTION public.vector_typmod_in(cstring[])
 RETURNS integer
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/vector', $function$vector_typmod_in$function$

`

```


## Triggers

```sql
### Trigger: ai_settings_updated_at
- Table: ai_settings
- Function: EXECUTE FUNCTION update_ai_settings_updated_at()
- Events: UPDATE

### Trigger: auto_follow_mm_ai
- Table: profiles
- Function: EXECUTE FUNCTION handle_new_user_follow()
- Events: INSERT

### Trigger: check_engagement_verification_trigger
- Table: profiles
- Function: EXECUTE FUNCTION check_engagement_verification()
- Events: UPDATE

### Trigger: handle_collections_updated_at
- Table: collections
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: handle_favorites_updated_at
- Table: artwork_favorites
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: handle_feature_usage_updated_at
- Table: feature_usage
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: handle_follows_updated_at
- Table: follows
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: handle_gallery_visits_updated_at
- Table: gallery_visits
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: handle_updated_at
- Table: profiles
- Function: EXECUTE FUNCTION moddatetime('updated_at')
- Events: UPDATE

### Trigger: handle_updated_at
- Table: store_orders
- Function: EXECUTE FUNCTION moddatetime('updated_at')
- Events: UPDATE

### Trigger: handle_updated_at
- Table: store_products
- Function: EXECUTE FUNCTION moddatetime('updated_at')
- Events: UPDATE

### Trigger: handle_updated_at
- Table: store_settings
- Function: EXECUTE FUNCTION moddatetime('updated_at')
- Events: UPDATE

### Trigger: handle_updated_at
- Table: store_transfers
- Function: EXECUTE FUNCTION moddatetime('updated_at')
- Events: UPDATE

### Trigger: handle_user_sessions_updated_at
- Table: user_sessions
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: on_artwork_favorite
- Table: artwork_favorites
- Function: EXECUTE FUNCTION handle_artwork_favorite()
- Events: INSERT, DELETE

### Trigger: on_artwork_purchase
- Table: transactions
- Function: EXECUTE FUNCTION handle_artwork_purchase()
- Events: INSERT

### Trigger: set_status_timestamp
- Table: transactions
- Function: EXECUTE FUNCTION set_stripe_status_timestamp()
- Events: UPDATE

### Trigger: set_stripe_timestamps_trigger
- Table: transactions
- Function: EXECUTE FUNCTION set_stripe_timestamps()
- Events: UPDATE

### Trigger: set_updated_at
- Table: gallery_shows
- Function: EXECUTE FUNCTION update_updated_at_column()
- Events: UPDATE

### Trigger: set_updated_at
- Table: ghost_profiles
- Function: EXECUTE FUNCTION update_updated_at_column()
- Events: UPDATE

### Trigger: sync_full_name_trigger
- Table: profiles
- Function: EXECUTE FUNCTION sync_full_name()
- Events: UPDATE

### Trigger: sync_name_trigger
- Table: profiles
- Function: EXECUTE FUNCTION sync_name()
- Events: UPDATE

### Trigger: transaction_add_to_collection
- Table: transactions
- Function: EXECUTE FUNCTION add_artwork_to_collection()
- Events: UPDATE, INSERT

### Trigger: update_artist_features_updated_at
- Table: artist_features
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: update_artwork_embeddings_updated_at
- Table: artwork_embeddings
- Function: EXECUTE FUNCTION update_updated_at_column()
- Events: UPDATE

### Trigger: update_artworks_updated_at
- Table: artworks
- Function: EXECUTE FUNCTION update_updated_at_column()
- Events: UPDATE

### Trigger: update_engagement_score_on_favorite
- Table: artwork_favorites
- Function: EXECUTE FUNCTION update_profile_engagement_score()
- Events: INSERT, DELETE

### Trigger: update_engagement_score_on_follow
- Table: follows
- Function: EXECUTE FUNCTION update_profile_engagement_score()
- Events: INSERT, DELETE

### Trigger: update_engagement_score_on_visit
- Table: gallery_visits
- Function: EXECUTE FUNCTION update_profile_engagement_score()
- Events: INSERT

### Trigger: update_ghost_totals
- Table: transactions
- Function: EXECUTE FUNCTION update_ghost_profile_totals()
- Events: UPDATE, INSERT

### Trigger: update_notification_settings_updated_at
- Table: notification_settings
- Function: EXECUTE FUNCTION update_updated_at_column()
- Events: UPDATE

### Trigger: update_partial_registrations_updated_at
- Table: partial_registrations
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: update_text_embeddings_updated_at
- Table: text_embeddings
- Function: EXECUTE FUNCTION update_updated_at_column()
- Events: UPDATE

### Trigger: update_user_preferences_updated_at
- Table: user_preferences
- Function: EXECUTE FUNCTION update_updated_at_column()
- Events: UPDATE

### Trigger: update_verification_progress
- Table: profiles
- Function: EXECUTE FUNCTION calculate_verification_progress()
- Events: UPDATE

### Trigger: update_verification_progress_updated_at
- Table: verification_progress
- Function: EXECUTE FUNCTION handle_updated_at()
- Events: UPDATE

### Trigger: update_verification_status_timestamp
- Table: profiles
- Function: EXECUTE FUNCTION update_verification_status_timestamp()
- Events: UPDATE

```


## Views

```sql
### View: artwork_counts

`sql
 SELECT p.id AS profile_id,
    count(a.id) AS artwork_count
   FROM (profiles p
     LEFT JOIN artworks a ON ((a.artist_id = p.id)))
  WHERE ((auth.uid() = p.id) OR (EXISTS ( SELECT 1
           FROM profiles
          WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::user_role)))))
  GROUP BY p.id;
`

### View: artworks_with_artist

`sql
 SELECT a.id,
    a.title,
    a.description,
    a.price,
    a.status,
    a.images,
    a.display_order,
    a.created_at,
    a.updated_at,
    a.artist_id,
    p.name AS artist_name,
    p.full_name AS artist_full_name,
    p.bio AS artist_bio,
    p.avatar_url AS artist_avatar_url,
    p.role AS artist_role
   FROM (artworks a
     LEFT JOIN profiles p ON ((p.id = a.artist_id)));
`

### View: profile_roles

`sql
 SELECT p.id,
        CASE
            WHEN ((p.role)::text = 'artist'::text) THEN 'verified_artist'::user_role
            ELSE p.role
        END AS mapped_role,
    p.role AS original_role
   FROM profiles p;
`

```


## Indexes

```sql
### Table: ai_settings
- ai_settings_pkey: CREATE UNIQUE INDEX ai_settings_pkey ON public.ai_settings USING btree (id)
- ai_settings_singleton: CREATE UNIQUE INDEX ai_settings_singleton ON public.ai_settings USING btree ((true))

### Table: artist_features
- artist_features_pkey: CREATE UNIQUE INDEX artist_features_pkey ON public.artist_features USING btree (user_id, feature_name)
- idx_artist_features_user_id: CREATE INDEX idx_artist_features_user_id ON public.artist_features USING btree (user_id)

### Table: artwork_embeddings
- artwork_embeddings_artwork_id_idx: CREATE INDEX artwork_embeddings_artwork_id_idx ON public.artwork_embeddings USING btree (artwork_id)
- artwork_embeddings_embedding_idx: CREATE INDEX artwork_embeddings_embedding_idx ON public.artwork_embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists='100')
- artwork_embeddings_pkey: CREATE UNIQUE INDEX artwork_embeddings_pkey ON public.artwork_embeddings USING btree (id)
- artwork_embeddings_type_idx: CREATE INDEX artwork_embeddings_type_idx ON public.artwork_embeddings USING btree (embedding_type)

### Table: artwork_embeddings_gemini
- artwork_embeddings_gemini_embedding_idx: CREATE INDEX artwork_embeddings_gemini_embedding_idx ON public.artwork_embeddings_gemini USING ivfflat (embedding vector_cosine_ops) WITH (lists='100')
- artwork_embeddings_gemini_pkey: CREATE UNIQUE INDEX artwork_embeddings_gemini_pkey ON public.artwork_embeddings_gemini USING btree (id)

### Table: artwork_favorites
- artwork_favorites_pkey: CREATE UNIQUE INDEX artwork_favorites_pkey ON public.artwork_favorites USING btree (user_id, artwork_id)
- idx_favorites_artwork: CREATE INDEX idx_favorites_artwork ON public.artwork_favorites USING btree (artwork_id)
- idx_favorites_created_at: CREATE INDEX idx_favorites_created_at ON public.artwork_favorites USING btree (created_at)
- idx_favorites_user: CREATE INDEX idx_favorites_user ON public.artwork_favorites USING btree (user_id)

### Table: artworks
- artworks_artist_id_idx: CREATE INDEX artworks_artist_id_idx ON public.artworks USING btree (artist_id)
- artworks_display_order_idx: CREATE INDEX artworks_display_order_idx ON public.artworks USING btree (artist_id, display_order)
- artworks_pkey: CREATE UNIQUE INDEX artworks_pkey ON public.artworks USING btree (id)
- artworks_status_idx: CREATE INDEX artworks_status_idx ON public.artworks USING btree (status)
- idx_artworks_ai_generated: CREATE INDEX idx_artworks_ai_generated ON public.artworks USING btree (ai_generated) WHERE (ai_generated = true)

### Table: chat_history
- chat_history_artwork_id_idx: CREATE INDEX chat_history_artwork_id_idx ON public.chat_history USING btree (artwork_id)
- chat_history_created_at_idx: CREATE INDEX chat_history_created_at_idx ON public.chat_history USING btree (created_at)
- chat_history_message_embedding_idx: CREATE INDEX chat_history_message_embedding_idx ON public.chat_history USING ivfflat (message_embedding vector_cosine_ops) WITH (lists='100')
- chat_history_pkey: CREATE UNIQUE INDEX chat_history_pkey ON public.chat_history USING btree (id)
- chat_history_response_embedding_idx: CREATE INDEX chat_history_response_embedding_idx ON public.chat_history USING ivfflat (response_embedding vector_cosine_ops) WITH (lists='100')
- chat_history_user_id_idx: CREATE INDEX chat_history_user_id_idx ON public.chat_history USING btree (user_id)

### Table: collection_items
- collection_items_pkey: CREATE UNIQUE INDEX collection_items_pkey ON public.collection_items USING btree (collection_id, artwork_id)
- idx_collection_items_added_at: CREATE INDEX idx_collection_items_added_at ON public.collection_items USING btree (added_at)
- idx_collection_items_artwork_id: CREATE INDEX idx_collection_items_artwork_id ON public.collection_items USING btree (artwork_id)
- idx_collection_items_collection_id: CREATE INDEX idx_collection_items_collection_id ON public.collection_items USING btree (collection_id)
- idx_collection_items_display_order: CREATE INDEX idx_collection_items_display_order ON public.collection_items USING btree (collection_id, display_order)
- idx_collection_items_order: CREATE INDEX idx_collection_items_order ON public.collection_items USING btree (collection_id, display_order)
- idx_collection_items_transaction_id: CREATE INDEX idx_collection_items_transaction_id ON public.collection_items USING btree (transaction_id)
- one_transaction_per_item: CREATE UNIQUE INDEX one_transaction_per_item ON public.collection_items USING btree (transaction_id)
- unique_artwork_per_collection: CREATE UNIQUE INDEX unique_artwork_per_collection ON public.collection_items USING btree (collection_id, artwork_id)

### Table: collection_views
- collection_views_collection_id_idx: CREATE INDEX collection_views_collection_id_idx ON public.collection_views USING btree (collection_id)
- collection_views_pkey: CREATE UNIQUE INDEX collection_views_pkey ON public.collection_views USING btree (id)
- collection_views_viewed_at_idx: CREATE INDEX collection_views_viewed_at_idx ON public.collection_views USING btree (viewed_at)
- collection_views_viewer_id_idx: CREATE INDEX collection_views_viewer_id_idx ON public.collection_views USING btree (viewer_id)

### Table: collections
- collections_pkey: CREATE UNIQUE INDEX collections_pkey ON public.collections USING btree (id)
- idx_collections_created_at: CREATE INDEX idx_collections_created_at ON public.collections USING btree (created_at)
- idx_collections_patron: CREATE INDEX idx_collections_patron ON public.collections USING btree (patron_id)
- idx_collections_patron_id: CREATE INDEX idx_collections_patron_id ON public.collections USING btree (patron_id)
- unique_collection_name: CREATE UNIQUE INDEX unique_collection_name ON public.collections USING btree (patron_id, name)

### Table: feature_usage
- feature_usage_feature_name_idx: CREATE INDEX feature_usage_feature_name_idx ON public.feature_usage USING btree (feature_name)
- feature_usage_pkey: CREATE UNIQUE INDEX feature_usage_pkey ON public.feature_usage USING btree (id)
- feature_usage_user_id_feature_name_key: CREATE UNIQUE INDEX feature_usage_user_id_feature_name_key ON public.feature_usage USING btree (user_id, feature_name)
- feature_usage_user_id_idx: CREATE INDEX feature_usage_user_id_idx ON public.feature_usage USING btree (user_id)

### Table: featured_artist
- featured_artist_pkey: CREATE UNIQUE INDEX featured_artist_pkey ON public.featured_artist USING btree (id)
- single_active_featured_artist: CREATE INDEX single_active_featured_artist ON public.featured_artist USING btree (active) WHERE (active = true)

### Table: follows
- follows_pkey: CREATE UNIQUE INDEX follows_pkey ON public.follows USING btree (follower_id, following_id)
- idx_follows_created_at: CREATE INDEX idx_follows_created_at ON public.follows USING btree (created_at)
- idx_follows_follower: CREATE INDEX idx_follows_follower ON public.follows USING btree (follower_id)
- idx_follows_following: CREATE INDEX idx_follows_following ON public.follows USING btree (following_id)

### Table: gallery_dates
- gallery_dates_pkey: CREATE UNIQUE INDEX gallery_dates_pkey ON public.gallery_dates USING btree (date)

### Table: gallery_show_artworks
- gallery_show_artworks_pkey: CREATE UNIQUE INDEX gallery_show_artworks_pkey ON public.gallery_show_artworks USING btree (show_id, artwork_id)

### Table: gallery_shows
- gallery_shows_pkey: CREATE UNIQUE INDEX gallery_shows_pkey ON public.gallery_shows USING btree (id)
- idx_gallery_shows_created_by: CREATE INDEX idx_gallery_shows_created_by ON public.gallery_shows USING btree (created_by)
- idx_gallery_shows_dates: CREATE INDEX idx_gallery_shows_dates ON public.gallery_shows USING btree (start_date, end_date)
- idx_gallery_shows_status: CREATE INDEX idx_gallery_shows_status ON public.gallery_shows USING btree (status)

### Table: gallery_visits
- gallery_visits_created_at_idx: CREATE INDEX gallery_visits_created_at_idx ON public.gallery_visits USING btree (created_at)
- gallery_visits_pkey: CREATE UNIQUE INDEX gallery_visits_pkey ON public.gallery_visits USING btree (id)
- gallery_visits_scanned_by_idx: CREATE INDEX gallery_visits_scanned_by_idx ON public.gallery_visits USING btree (scanned_by)
- gallery_visits_user_id_idx: CREATE INDEX gallery_visits_user_id_idx ON public.gallery_visits USING btree (user_id)

### Table: ghost_profiles
- ghost_profiles_pkey: CREATE UNIQUE INDEX ghost_profiles_pkey ON public.ghost_profiles USING btree (id)
- idx_ghost_profiles_claimed: CREATE INDEX idx_ghost_profiles_claimed ON public.ghost_profiles USING btree (claimed_profile_id) WHERE (claimed_profile_id IS NOT NULL)
- idx_ghost_profiles_claimed_profile_id: CREATE INDEX idx_ghost_profiles_claimed_profile_id ON public.ghost_profiles USING btree (claimed_profile_id)
- idx_ghost_profiles_email: CREATE INDEX idx_ghost_profiles_email ON public.ghost_profiles USING btree (email)
- idx_ghost_profiles_is_visible: CREATE INDEX idx_ghost_profiles_is_visible ON public.ghost_profiles USING btree (is_visible) WHERE (is_visible = true)
- idx_ghost_profiles_stripe_customer: CREATE INDEX idx_ghost_profiles_stripe_customer ON public.ghost_profiles USING btree (stripe_customer_id)
- unique_email: CREATE UNIQUE INDEX unique_email ON public.ghost_profiles USING btree (email)
- unique_stripe_customer: CREATE UNIQUE INDEX unique_stripe_customer ON public.ghost_profiles USING btree (stripe_customer_id) WHERE (stripe_customer_id IS NOT NULL)

### Table: notification_settings
- idx_notification_settings_type: CREATE INDEX idx_notification_settings_type ON public.notification_settings USING btree (notification_type)
- idx_notification_settings_user_id: CREATE INDEX idx_notification_settings_user_id ON public.notification_settings USING btree (user_id)
- notification_settings_pkey: CREATE UNIQUE INDEX notification_settings_pkey ON public.notification_settings USING btree (id)
- notification_settings_user_id_notification_type_key: CREATE UNIQUE INDEX notification_settings_user_id_notification_type_key ON public.notification_settings USING btree (user_id, notification_type)

### Table: partial_registrations
- idx_partial_registrations_email: CREATE INDEX idx_partial_registrations_email ON public.partial_registrations USING btree (email)
- partial_registrations_pkey: CREATE UNIQUE INDEX partial_registrations_pkey ON public.partial_registrations USING btree (id)

### Table: profiles
- idx_profiles_artist_type: CREATE INDEX idx_profiles_artist_type ON public.profiles USING btree (artist_type)
- idx_profiles_artist_type_created_at: CREATE INDEX idx_profiles_artist_type_created_at ON public.profiles USING btree (artist_type, created_at DESC)
- idx_profiles_artist_type_view_count: CREATE INDEX idx_profiles_artist_type_view_count ON public.profiles USING btree (artist_type, view_count DESC)
- idx_profiles_bio_gin: CREATE INDEX idx_profiles_bio_gin ON public.profiles USING gin (to_tsvector('english'::regconfig, COALESCE(bio, ''::text)))
- idx_profiles_created_at: CREATE INDEX idx_profiles_created_at ON public.profiles USING btree (created_at)
- idx_profiles_exhibition_artist_type: CREATE INDEX idx_profiles_exhibition_artist_type ON public.profiles USING btree (exhibition_badge DESC, artist_type DESC, created_at DESC)
- idx_profiles_exhibition_badge: CREATE INDEX idx_profiles_exhibition_badge ON public.profiles USING btree (exhibition_badge)
- idx_profiles_full_name: CREATE INDEX idx_profiles_full_name ON public.profiles USING btree (full_name)
- idx_profiles_location: CREATE INDEX idx_profiles_location ON public.profiles USING btree (location)
- idx_profiles_medium: CREATE INDEX idx_profiles_medium ON public.profiles USING gin (medium)
- idx_profiles_view_count: CREATE INDEX idx_profiles_view_count ON public.profiles USING btree (view_count)
- profiles_email_key: CREATE UNIQUE INDEX profiles_email_key ON public.profiles USING btree (email)
- profiles_pkey: CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id)

### Table: role_conversions
- role_conversions_created_at_idx: CREATE INDEX role_conversions_created_at_idx ON public.role_conversions USING btree (created_at)
- role_conversions_pkey: CREATE UNIQUE INDEX role_conversions_pkey ON public.role_conversions USING btree (id)
- role_conversions_user_id_idx: CREATE INDEX role_conversions_user_id_idx ON public.role_conversions USING btree (user_id)

### Table: store_orders
- store_orders_pkey: CREATE UNIQUE INDEX store_orders_pkey ON public.store_orders USING btree (id)
- store_orders_stripe_payment_intent_key: CREATE UNIQUE INDEX store_orders_stripe_payment_intent_key ON public.store_orders USING btree (stripe_payment_intent)
- store_orders_stripe_session_id_key: CREATE UNIQUE INDEX store_orders_stripe_session_id_key ON public.store_orders USING btree (stripe_session_id)

### Table: store_products
- idx_store_products_inventory_status: CREATE INDEX idx_store_products_inventory_status ON public.store_products USING btree (inventory_status)
- idx_store_products_payment_link: CREATE INDEX idx_store_products_payment_link ON public.store_products USING btree (payment_link_id)
- store_products_pkey: CREATE UNIQUE INDEX store_products_pkey ON public.store_products USING btree (id)
- store_products_stripe_product_id_key: CREATE UNIQUE INDEX store_products_stripe_product_id_key ON public.store_products USING btree (stripe_product_id)

### Table: store_settings
- store_settings_pkey: CREATE UNIQUE INDEX store_settings_pkey ON public.store_settings USING btree (profile_id)
- store_settings_stripe_account_id_key: CREATE UNIQUE INDEX store_settings_stripe_account_id_key ON public.store_settings USING btree (stripe_account_id)

### Table: store_transfers
- store_transfers_pkey: CREATE UNIQUE INDEX store_transfers_pkey ON public.store_transfers USING btree (id)
- store_transfers_stripe_transfer_id_key: CREATE UNIQUE INDEX store_transfers_stripe_transfer_id_key ON public.store_transfers USING btree (stripe_transfer_id)

### Table: text_embeddings
- text_embeddings_content_id_idx: CREATE INDEX text_embeddings_content_id_idx ON public.text_embeddings USING btree (content_id)
- text_embeddings_content_type_idx: CREATE INDEX text_embeddings_content_type_idx ON public.text_embeddings USING btree (content_type)
- text_embeddings_embedding_idx: CREATE INDEX text_embeddings_embedding_idx ON public.text_embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists='100')
- text_embeddings_pkey: CREATE UNIQUE INDEX text_embeddings_pkey ON public.text_embeddings USING btree (id)

### Table: transactions
- idx_transactions_buyer: CREATE INDEX idx_transactions_buyer ON public.transactions USING btree (buyer_id)
- idx_transactions_buyer_ghost: CREATE INDEX idx_transactions_buyer_ghost ON public.transactions USING btree (buyer_id, ghost_profile_id)
- idx_transactions_ghost: CREATE INDEX idx_transactions_ghost ON public.transactions USING btree (ghost_profile_id)
- idx_transactions_ghost_profile: CREATE INDEX idx_transactions_ghost_profile ON public.transactions USING btree (ghost_profile_id)
- idx_transactions_ghost_profile_id: CREATE INDEX idx_transactions_ghost_profile_id ON public.transactions USING btree (ghost_profile_id)
- idx_transactions_payment_status: CREATE INDEX idx_transactions_payment_status ON public.transactions USING btree (status)
- idx_transactions_stripe_created: CREATE INDEX idx_transactions_stripe_created ON public.transactions USING btree (stripe_created DESC)
- transactions_artist_id_idx: CREATE INDEX transactions_artist_id_idx ON public.transactions USING btree (artist_id)
- transactions_artwork_id_idx: CREATE INDEX transactions_artwork_id_idx ON public.transactions USING btree (artwork_id)
- transactions_buyer_id_idx: CREATE INDEX transactions_buyer_id_idx ON public.transactions USING btree (buyer_id)
- transactions_ghost_profile_id_idx: CREATE INDEX transactions_ghost_profile_id_idx ON public.transactions USING btree (ghost_profile_id)
- transactions_pkey: CREATE UNIQUE INDEX transactions_pkey ON public.transactions USING btree (id)
- transactions_status_idx: CREATE INDEX transactions_status_idx ON public.transactions USING btree (status)
- transactions_stripe_payment_intent_id_key: CREATE UNIQUE INDEX transactions_stripe_payment_intent_id_key ON public.transactions USING btree (stripe_payment_intent_id)

### Table: user_accessible_ghost_profiles
- idx_user_accessible_ghost_profiles: CREATE UNIQUE INDEX idx_user_accessible_ghost_profiles ON public.user_accessible_ghost_profiles USING btree (ghost_profile_id)

### Table: user_events
- user_events_created_at_idx: CREATE INDEX user_events_created_at_idx ON public.user_events USING btree (created_at)
- user_events_event_type_idx: CREATE INDEX user_events_event_type_idx ON public.user_events USING btree (event_type)
- user_events_pkey: CREATE UNIQUE INDEX user_events_pkey ON public.user_events USING btree (id)
- user_events_session_id_idx: CREATE INDEX user_events_session_id_idx ON public.user_events USING btree (session_id)
- user_events_user_id_idx: CREATE INDEX user_events_user_id_idx ON public.user_events USING btree (user_id)

### Table: user_preferences
- idx_user_preferences_user_id: CREATE INDEX idx_user_preferences_user_id ON public.user_preferences USING btree (user_id)
- user_preferences_pkey: CREATE UNIQUE INDEX user_preferences_pkey ON public.user_preferences USING btree (id)
- user_preferences_user_id_key: CREATE UNIQUE INDEX user_preferences_user_id_key ON public.user_preferences USING btree (user_id)

### Table: user_sessions
- user_sessions_pkey: CREATE UNIQUE INDEX user_sessions_pkey ON public.user_sessions USING btree (id)
- user_sessions_session_id_idx: CREATE INDEX user_sessions_session_id_idx ON public.user_sessions USING btree (session_id)
- user_sessions_session_id_key: CREATE UNIQUE INDEX user_sessions_session_id_key ON public.user_sessions USING btree (session_id)
- user_sessions_started_at_idx: CREATE INDEX user_sessions_started_at_idx ON public.user_sessions USING btree (started_at)
- user_sessions_user_id_idx: CREATE INDEX user_sessions_user_id_idx ON public.user_sessions USING btree (user_id)

### Table: verification_progress
- idx_verification_progress_user_id: CREATE INDEX idx_verification_progress_user_id ON public.verification_progress USING btree (user_id)
- verification_progress_pkey: CREATE UNIQUE INDEX verification_progress_pkey ON public.verification_progress USING btree (id)
- verification_progress_user_id_key: CREATE UNIQUE INDEX verification_progress_user_id_key ON public.verification_progress USING btree (user_id)

```


