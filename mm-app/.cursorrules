# Meaning Machine

Every time you choose to apply a rule(s), explicitly state the rule(s) in the output. You can abbreviate the rule description to a single word or phrase.

- Do not over engineer.

- 'gemini-1.5-flash' is the correct model for image analysis.

## Project Context
This project involves integrating various features and services to create a comprehensive platform for artists and administrators. The key components include:

- **Stripe Integration**: Setting up Stripe for payment processing, including creating payment intents, handling webhooks, and managing artist payouts.
- **Artist Application Process**: Implementing a detailed application process for artists, including form submission, admin review, and notifications.
- **AI Gallery Assistant**: Setting up an AI-powered assistant using Google Cloud Multimodal Live API for real-time conversation and session management.
- **Admin and Artist Dashboards**: Creating dashboards for both admins and artists to manage applications, view sales history, and handle payouts.
- **Security and Access Control**: Implementing role-based access control, data validation, and rate limiting to ensure platform security and integrity.

## Code Style and Structure
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure repository files as follows:
```
## Directory Structure

# Core directory structure:
```
mm-app/
├── app/              # Next.js app router pages
├── components/       # React components
├── lib/             # Core utilities
├── public/          # Static assets
├── utils/           # Helper functions
└── docs/            # Documentation
```

# For more detailed organization:
```
MM-web/
mm-app/
├── app/
│   ├── (auth-pages)/
│   │   ├── sign-in/
│   │   ├── sign-up/
│   │   └── reset-password/
│   ├── actions/
│   │   └── upload.ts
│   ├── admin/
│   │   └── applications/
│   ├── api/
│   │   ├── artworks/
│   │   │   ├── create/
│   │   │   └── upload/
│   │   └── webhooks/
│   ├── artist/
│   │   └── artworks/
│   │       ├── new/
│   │       ├── artworks-client.tsx
│   │       └── page.tsx
│   ├── artist-application/
│   ├── auth/
│   │   └── callback/
│   ├── profile/
│   │   └── edit/
│   │   └── application/
│   │   │   └── page.tsx
│   ├── protected/
│   ├── actions.ts
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx
├── components/
│   ├── artwork/
│   │   ├── artwork-card.tsx
│   │   ├── artwork-form.tsx
│   │   └── artwork-upload.tsx
│   ├── auth/
│   ├── ui/
├── docs/
│   └── implementation.md
├── lib/
│   └── utils.ts
├── public/
│   └── images/
│       ├── favicons/
│       └── logos/
├── scripts/
│   └── create-test-users.ts
├── supabase/
│   ├── migrations/
│   └── config.toml
├── utils/
│   ├── supabase/
│   │   ├── action.ts
│   │   ├── client.ts
│   │   ├── middleware.ts
│   │   └── server.ts
│   └── utils.ts
├── .env.local
├── middleware.ts
├── next.config.js
├── package.json
└── [config files]
```

## Tech Stack
- Next.js   
- React
- TypeScript
- Tailwind CSS
- Shadcn UI
- Express.js
- Supabase
- Stripe

## Key Supabase Usage
- Do not use supabases auth-helper library
- Supabase handles cookies


## Naming Conventions
- Use lowercase with dashes for directories (e.g., components/form-wizard)
- Favor named exports for components and utilities

## TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use const objects with 'as const' assertion
- Use functional components with TypeScript interfaces
- Use absolute imports for all files @/...
- Avoid try/catch blocks unless there is good reason to translate or handle error in that abstraction
- Use explicit return types for all functions

## State Management
- Use React Context for global state when needed
- Implement proper cleanup in useEffect hooks

## Syntax and Formatting
- Use "function" keyword for pure functions
- Avoid unnecessary curly braces in conditionals
- Use declarative JSX
- Implement proper TypeScript discriminated unions for message types

## UI and Styling
- Use Shadcn UI and Radix for components
- use `npx shadcn@latest add <component-name>` to add new shadcn components
- Implement Tailwind CSS for styling
- When adding new shadcn component, document the installation command

## Error Handling
- Implement proper error boundaries
- Log errors appropriately for debugging
- Provide user-friendly error messages
- Handle network failures gracefully

## Testing
- Write unit tests for utilities and components
- Implement E2E tests for critical flows
- Test across different Chrome versions
- Test memory usage and performance

## Security
- Implement Content Security Policy
- Sanitize user inputs
- Handle sensitive data properly
- Implement proper CORS handling

## Git Usage
Commit Message Prefixes:
- "fix:" for bug fixes
- "feat:" for new features
- "perf:" for performance improvements
- "docs:" for documentation changes
- "style:" for formatting changes
- "refactor:" for code refactoring
- "test:" for adding missing tests
- "chore:" for maintenance tasks

Rules:
- Use lowercase for commit messages
- Keep the summary line concise
- Include description for non-obvious changes
- Reference issue numbers when applicable

## Documentation
- Maintain clear README with setup instructions
- Document API interactions and data flows
- Keep manifest.json well-documented
- Document permission requirements

## Development Workflow
- Use proper version control
- Implement proper code review process
- Test in multiple environments
- Follow semantic versioning for releases
- Maintain changelog

## Accessibility Standards
- Build accessibility from the start
- Test with keyboard navigation
- Maintain proper heading hierarchy
- Ensure proper contrast ratios

# API Design
- Keep endpoints focused and specific
- Use consistent response patterns
- Handle errors at the source
- Design with scalability in mind

## Data Flow
- Prefer server components for data fetching
- Keep client-side state minimal
- Use server actions for mutations
- Handle loading and error states at boundaries

## Performance
- Optimize only with measurable benefits
- Prefer static over dynamic when possible
- Cache at the appropriate level
- Load assets strategically

## Component Architecture
- Keep components focused and single-purpose
- Prefer composition over configuration
- Share logic through hooks, not inheritance
- Maintain clear component boundaries